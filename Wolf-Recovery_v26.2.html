<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wolf Recovery — v26.2 (Integration Phase Language + Harmonized Colors)</title>
  <style>
    :root {
      --headerH: 0px;
      --pad: 12px;
      --radius: 14px;
    }

    body {
      font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      background: #f6f7f9;
      color: #111;
    }

    header {
      padding: 18px 16px;
      background: #fff;
      border-bottom: 1px solid #e6e8ee;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      margin: 0;
      font-size: 18px;
    }

    header .sub {
      margin-top: 6px;
      color: #555;
      font-size: 13px;
      line-height: 1.3;
    }

    main {
      padding: 16px;
      max-width: 1160px;
      margin: 0 auto;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    @media (min-width: 980px) {
      .grid {
        grid-template-columns: 430px 1fr;
        align-items: start;
      }
    }

    .card {
      background: #fff;
      border: 1px solid #e6e8ee;
      border-radius: var(--radius);
      padding: 14px;
    }

    .card h2 {
      margin: 0 0 10px;
      font-size: 15px;
    }

    label {
      display: block;
      font-size: 12px;
      color: #333;
      margin: 10px 0 6px;
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #d7dbe6;
      background: #fff;
      font-size: 14px;
      box-sizing: border-box;
    }

    textarea {
      min-height: 64px;
      resize: vertical;
    }

    .row2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
    }

    .btnrow {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    button {
      border: 1px solid #d7dbe6;
      background: #111;
      color: #fff;
      padding: 10px 12px;
      border-radius: 10px;
      font-weight: 650;
      cursor: pointer;
    }

    button.secondary {
      background: #fff;
      color: #111;
    }

    button.danger {
      background: #b00020;
      border-color: #b00020;
    }

    button:disabled {
      opacity: .5;
      cursor: not-allowed;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #d7dbe6;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: #222;
      background: #fff;
    }

    .phasePill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 700;
      font-size: 12px;
      border: 1px solid #d7dbe6;
      background: #fff;
      color: #111;
    }

    .phase-regulated {
      background: #e7f6ec;
      border-color: #b8e0c4;
    }

    .phase-lag {
      background: #e7f0ff;
      border-color: #b8cdfa;
    }

    .phase-transitional {
      background: #f1eaff;
      border-color: #d0c2ff;
    }

    .phase-reset {
      background: #fde8e8;
      border-color: #f5b4b4;
    }

    .kpi {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
      margin-top: 10px;
    }

    .kpi .box {
      border: 1px solid #e6e8ee;
      border-radius: 12px;
      padding: 10px;
      background: #fcfcfd;
    }

    /* KPI layout */
    .recBox {
      grid-column: span 6;
    }

    .miniBox {
      grid-column: span 3;
    }

    .crashBox {
      grid-column: span 4;
    }

    .loadBox {
      grid-column: span 4;
    }

    .fatigueBox {
      grid-column: span 4;
    }

    .tensionBox {
      grid-column: span 4;
    }

    .diurnalBox {
      grid-column: span 4;
    }

    .val.big {
      font-size: 18px;
      line-height: 1.25;
      font-weight: 750;
    }

    .whyBullets {
      margin-top: 8px;
    }

    .whyBullets ul {
      margin: 8px 0 0 18px;
      padding: 0;
    }

    .sub {
      margin-top: 4px;
      color: #4b5563;
      font-size: 12.5px;
    }

    .micro {
      margin-top: 6px;
      color: #6b7280;
      font-size: 12px;
      line-height: 1.25;
    }

    .crashBox {
      background: #fff7ed;
      border-color: #fed7aa;
    }

    .fatigueBox {
      background: #f8fafc;
    }

    .tensionBox {
      background: #f8fafc;
    }

    .diurnalBox {
      background: #f0fdf4;
      border-color: #bbf7d0;
    }

    @media (max-width: 980px) {
      .recBox {
        grid-column: span 12;
      }

      .miniBox {
        grid-column: span 4;
      }

      .crashBox,
      .fatigueBox,
      .tensionBox,
      .diurnalBox {
        grid-column: span 6;
      }
    }

    @media (max-width: 680px) {

      .miniBox,
      .crashBox,
      .fatigueBox,
      .tensionBox,
      .diurnalBox {
        grid-column: span 12;
      }
    }

    .kpi .box .lbl {
      font-size: 11px;
      color: #555;
    }

    .kpi .box .val {
      font-size: 18px;
      font-weight: 760;
      margin-top: 4px;
    }

    .kpi .box .hint {
      font-size: 11px;
      color: #666;
      margin-top: 4px;
      line-height: 1.2;
    }

    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size: 12px;
    }

    th,
    td {
      padding: 8px 8px;
      border-bottom: 1px solid #eef0f6;
      vertical-align: top;
    }

    th {
      text-align: left;
      color: #444;
      font-weight: 700;
      position: sticky;
      top: calc(var(--headerH) + env(safe-area-inset-top));
      background: #fff;
      z-index: 5;
    }

    tr:hover td {
      background: #fbfbff;
    }

    .tag {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid #d7dbe6;
      background: #fff;
    }

    .green {
      border-color: #1b7f3b;
      color: #1b7f3b;
    }

    .blue {
      border-color: #1f5fbf;
      color: #1f5fbf;
    }

    .yellow {
      border-color: #b07a00;
      color: #b07a00;
    }

    .red {
      border-color: #b00020;
      color: #b00020;
    }

    .muted {
      color: #666;
    }

    .small {
      font-size: 11px;
      color: #666;
      line-height: 1.2;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }

    .hr {
      height: 1px;
      background: #eef0f6;
      margin: 12px 0;
    }

    .flex {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .right {
      margin-left: auto;
    }

    .note {
      background: #f0f4ff;
      border: 1px solid #d8e2ff;
      padding: 10px;
      border-radius: 12px;
      font-size: 12px;
      color: #203a86;
      line-height: 1.35;
    }

    .warn {
      background: #fff8e6;
      border: 1px solid #ffe1a6;
      padding: 10px;
      border-radius: 12px;
      font-size: 12px;
      color: #6b4a00;
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <header>
    <h1>Wolf Recovery <span class="muted">v26.2</span></h1>
    <div class="sub">
      Local-first app (single-file). Can store data in browser storage, or in a real <span class="mono">data.json</span>
      file (recommended), and later sync to Supabase.
    </div>
  </header>

  <main>
    <div class="grid">
      <section class="card">
        <h2>Data Location</h2>
        <div class="note">
          <div><b>Current source:</b> <span id="dataSource" class="mono">localStorage</span></div>
          <div class="small">Recommended: open a <span class="mono">data.json</span> file once, then use “Save to File”
            so your data lives in your folder.</div>
        </div>

        <div class="btnrow" style="margin-top:10px">
          <button id="openFileBtn" class="secondary">Open data.json</button>
          <button id="saveFileBtn" class="secondary" disabled>Save to File</button>
          <button id="exportJsonBtn" class="secondary">Export JSON</button>
          <button id="importJsonBtn" class="secondary">Import JSON</button>
          <button id="exportCsvBtn" class="secondary">Export CSV</button>
          <button id="importCsvBtn">Import CSV</button>
          <input id="importCsvInput" type="file" accept=".csv,text/csv" style="display:none" />
        </div>
        <div id="importStatus" class="small muted"
          style="margin-top:10px; white-space:pre-wrap; border:1px solid #eef0f6; padding:8px; border-radius:8px">Import
          status: —</div>

        <input id="importFileInput" type="file" accept="application/json" style="display:none" />

        <div class="hr"></div>

        <h2>Daily Entry</h2>

        <label for="date">Date</label>
        <input id="date" type="date" />

        <div class="hr"></div>

        <h2 style="margin-top:0">Device Metrics</h2>

        <div class="row3">
          <div>
            <label for="mReady">Morpheus Morning Readiness (%) <span class="small muted">(wake HRV test)</span></label>
            <input id="mReady" type="number" step="1" min="0" max="100" />
          </div>
          <div>
            <label for="mHrv">Morpheus HRV</label>
            <input id="mHrv" type="number" step="1" min="0" />
          </div>
          <div>
            <label for="whoopRec">Whoop Recovery (0–100) (optional)</label>
            <input id="whoopRec" type="number" step="1" min="0" max="100" />
          </div>
        </div>
        <div class="small muted" style="margin:-6px 0 10px 0">
          Morpheus is a <b>morning snapshot</b> (your 2–3 min HRV check after waking). It does <b>not</b> measure
          overnight sleep; a low score can reflect an AM autonomic dip even after a decent night.
        </div>

        <div class="row3">
          <div>
            <label for="ouraRec">Oura Recovery (0–100)</label>
            <input id="ouraRec" type="number" step="1" min="0" max="100" />
          </div>
          <div>
            <label for="whoopRhr">Whoop RHR (bpm)</label>
            <input id="whoopRhr" type="number" step="1" min="0" />
          </div>
          <div>
            <label for="ouraRhr">Oura RHR (bpm)</label>
            <input id="ouraRhr" type="number" step="1" min="0" />
          </div>
        </div>


        <div class="row2">
          <div>
            <label for="steps">Steps (optional — fill later, after the day)</label>
            <input id="steps" type="number" step="1" min="0" placeholder="Leave blank in the morning" />
            <div class="small" style="margin-top:6px">
              <label style="display:flex; gap:8px; align-items:center; margin:0">
                <input id="morningEntry" type="checkbox" style="width:auto; margin:0" />
                <span><b>Morning entry (steps pending)</b> — exclude steps from today’s Vote/Outliers until you fill
                  them later.</span>
              </label>
            </div>
          </div>
          <div>
            <label for="fatigue">Fatigue (1–10)</label>
            <input id="fatigue" type="number" step="1" min="1" max="10" />
          </div>
        </div>

        <div class="row2">
          <div>
            <label for="amState">AM State (how you woke up)</label>
            <select id="amState">
              <option value="">—</option>
              <option value="FLAT">Flat / Heavy</option>
              <option value="MIXED">Mixed</option>
              <option value="ONLINE">Online / Capable</option>
            </select>
          </div>
          <div>
            <label for="pmShift">PM Shift (did it lift later?)</label>
            <select id="pmShift">
              <option value="">—</option>
              <option value="NO">Did not lift</option>
              <option value="SOME">Lifted some</option>
              <option value="CLEAR">Lifted clearly</option>
            </select>
          </div>
        </div>

        <div class="row2">
          <div>
            <label for="liftTime">Lift time (optional)</label>
            <select id="liftTime">
              <option value="">—</option>
              <option value="12">By ~12pm</option>
              <option value="15">By ~3pm</option>
              <option value="18">By ~6pm</option>
              <option value="UNK">Unknown</option>
            </select>
          </div>
          <div class="small muted" style="align-self:end; padding-bottom:6px">
            Quick CFS/ADT nuance: this captures the “half-full” part of the day if the system regulates later.
          </div>
        </div>


        <div class="row2">
          <div>
            <label for="resistance">Resistance Session?</label>
            <select id="resistance">
              <option value="N">No</option>
              <option value="Y">Yes</option>
            </select>
          </div>
          <div>
            <label for="joint">Joint/Tendon Warning (0–10)</label>
            <input id="joint" type="number" step="1" min="0" max="10" />
          </div>
          <div>
            <label for="limiter">Primary Limiter (optional)</label>
            <select id="limiter">
              <option value="AUTO">Auto (detect)</option>
              <option value="METABOLIC">Metabolic / neuro-energy</option>
              <option value="MECHANICAL">Mechanical / joints</option>
              <option value="MIXED">Mixed</option>
            </select>
          </div>
        </div>

        <label for="notes">Notes</label>
        <textarea id="notes" placeholder="sleep disruptions, meds timing, illness symptoms, travel, etc."></textarea>

        <div class="hr"></div>

        <div class="row2">
          <div>
            <label for="baseDays">Baseline window (days)</label>
            <select id="baseDays">
              <option value="7">7</option>
              <option value="10">10</option>
              <option value="14" selected>14</option>
              <option value="21">21</option>
            </select>
          </div>
          <div>
            <label for="mode">Guardrail Mode</label>
            <select id="mode">
              <option value="standard">Standard</option>
              <option value="adt" selected>ADT / joint-protective</option>
            </select>
          </div>
        </div>

        <div class="btnrow">
          <button id="addBtn">Add / Update Day</button>
          <button id="clearBtn" class="secondary">Clear Form</button>
          <button id="bundleBtn" class="secondary">Copy Analysis Bundle</button>
          <button id="resetBtn" class="danger">Reset All Data</button>
        </div>

        <div class="warn" style="margin-top:12px">
          Decision-support only, not diagnosis. If you have concerning symptoms, seek medical care.
        </div>
      </section>

      <section class="card">
        <div class="flex">
          <h2 style="margin:0">Dashboard</h2>
          <span class="pill right"><span class="muted">Entries:</span> <span id="entryCount"
              class="mono">0</span></span>
          <span class="pill"><span class="muted">Baseline:</span> <span id="baselineLabel"
              class="mono">14d</span></span>
          <span class="pill"><span class="muted">Mode:</span> <span id="modeLabel" class="mono">ADT</span></span>
        </div>

        <div class="kpi">
          <div class="box recBox">
            <div class="lbl">Today's Recommendation</div>
            <div class="val big" id="todayRec">—</div>
            <div class="whyBullets" id="todayWhy">—</div>
          </div>

          <div class="box miniBox">
            <div class="lbl">Current Integration Phase</div>
            <div class="val" id="todayVote">—</div>
            <div class="hint">System-wide phase based on combined device signals, symptoms, and recent load.</div>
          </div>

          <div class="box miniBox">
            <div class="lbl">Primary Limiter</div>
            <div class="val" id="primaryLimiter">—</div>
            <div class="hint" id="limiterWhy">Metabolic (neuro-energy), Mechanical (joints/tendons), or Mixed. You can
              override this in the form.</div>
          </div>

          <div class="box miniBox">
            <div class="lbl">Confidence</div>
            <div class="val" id="todayConf">—</div>
            <div class="hint">Higher = stronger agreement + fewer outliers.</div>
          </div>

          <div class="box miniBox">
            <div class="lbl">Odd-One-Out Device</div>
            <div class="val" id="oddOneOut">—</div>
            <div class="hint" id="oddWhy">—</div>
          </div>

          <div class="box crashBox">
            <div class="lbl">Integration Stress Signature (24–72h)</div>
            <div class="val" id="crashSig">—</div>
            <div class="hint" id="crashWhy">—</div>
          </div>

          <div class="box loadBox">
            <div class="lbl">Load Memory (PEM Reservoir)</div>
            <div class="val" id="loadMem">—</div>
            <div class="sub" id="loadMemStatus">—</div>
            <canvas id="loadChart" width="520" height="120"
              style="width:100%; height:120px; margin-top:8px; border-radius:12px; background:#fff;"></canvas>
            <div class="hint" id="loadWhy">Shows unabsorbed movement-load over the last 7–10 days. Rising/plateau =
              integration load still in process; falling = clearing.</div>
          </div>

          <div class="box fatigueBox">
            <div class="lbl">Neuro‑Energy (Fatigue)</div>
            <div class="val" id="fatigueSig">—</div>
            <div class="sub" id="fatigueDetail">—</div>
            <div class="hint" id="fatigueWhy">—</div>
          </div>

          <div class="box tensionBox">
            <div class="lbl">Signal Tension</div>
            <div class="val" id="signalTension">—</div>
            <div class="micro">What it means: signals point in different directions (often “capacity vs consolidation”).
              Not automatically a faulty device.</div>
            <div class="hint" id="tensionWhy">—</div>
          </div>

          <div class="box diurnalBox">
            <div class="lbl">Diurnal Arc (AM → PM)</div>
            <div class="val" id="diurnalArc">—</div>
            <div class="hint" id="diurnalWhy">—</div>
          </div>
        </div>
        <div class="hr"></div>

        <h2>Entries</h2>
        <div class="small">Tap a row to load it into the form for editing.</div>

        <div style="overflow:auto; max-height: 560px; margin-top:10px;">
          <table id="tbl">
            <thead>
              <tr>
                <th>Date</th>
                <th>Vote</th>
                <th>Outliers</th>
                <th>Conf</th>
                <th>Rec</th>
                <th class="muted">Notes</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>
    </div>
  </main>

  <script>

    function escapeHTML(str) {
      return String(str ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }



    function num(x, fallback = 0) {
      const n = (typeof x === "number") ? x : parseFloat(String(x ?? "").trim());
      return Number.isFinite(n) ? n : fallback;
    }

    function setTodayWhyBullets(text) {
      const el = document.getElementById("todayWhy");
      if (!el) return;
      const raw = String(text || "").trim();
      if (!raw) { el.innerHTML = "<li>—</li>"; return; }
      // split on semicolons or sentence boundaries
      let parts = raw.split(";").map(s => s.trim()).filter(Boolean);
      if (parts.length === 1) {
        parts = raw.split(/\. +/).map(s => s.trim()).filter(Boolean);
      }
      if (parts.length === 0) parts = [raw];
      // ensure li wrapper (works whether todayWhy is ul or div)
      el.innerHTML = parts.map(p => `<li>${escapeHTML(p.replace(/\.$/, ""))}.</li>`).join("");
    }

    const LS_KEY = "three_device_recovery_entries_v2";
    let fileHandle = null;

    function loadEntries() { try { return JSON.parse(localStorage.getItem(LS_KEY) || "[]"); } catch { return []; } }
    // CSV import uses these aliases
    function loadRows() { return loadEntries(); }
    function saveRows(arr) { saveEntries(arr); }
    function saveEntries(arr) { localStorage.setItem(LS_KEY, JSON.stringify(arr)); }
    function byDateAsc(a, b) { return (a.date || "").localeCompare(b.date || ""); }
    function parseNum(v) { if (v === "" || v == null) return null; const x = Number(v); return Number.isFinite(x) ? x : null; }
    function avg(arr) { if (!arr || !arr.length) return 0; let s = 0, c = 0; for (const v of arr) { const x = Number(v); if (Number.isFinite(x)) { s += x; c++; } } return c ? (s / c) : 0; }
    function fmt(n, d = 0) { if (n == null || Number.isNaN(n)) return ""; const x = Number(n); return Number.isFinite(x) ? x.toFixed(d) : ""; }
    function mean(xs) { const a = xs.filter(x => x != null && Number.isFinite(x)); if (!a.length) return null; return a.reduce((p, c) => p + c, 0) / a.length; }
    function sd(xs) { const a = xs.filter(x => x != null && Number.isFinite(x)); if (a.length < 2) return null; const m = mean(a); const v = a.reduce((p, c) => p + (c - m) * (c - m), 0) / (a.length - 1); return Math.sqrt(v); }
    function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }

    const TODAY = new Date().toISOString().slice(0, 10);

    function syncMorningEntryUI() {
      if (!window.els) return;
      const d = els.date.value || TODAY;
      const isToday = (d === TODAY);
      // Default: if date is today, assume morning entry unless user explicitly turned it off
      if (isToday && els.morningEntry.checked === false && els.morningEntry.dataset.userToggled !== "1") {
        els.morningEntry.checked = true;
      }
      if (!isToday) {
        els.morningEntry.checked = false;
        els.morningEntry.dataset.userToggled = "0";
      }
      const pending = els.morningEntry.checked && isToday;
      els.steps.disabled = pending;
      if (pending) {
        els.steps.value = "";
      }
    }

    function setDataSourceLabel() {
      const el = document.getElementById("dataSource");
      el.textContent = fileHandle ? "data.json (file-backed)" : "localStorage";
      document.getElementById("saveFileBtn").disabled = !fileHandle;
    }

    async function openDataFile() {
      if (!window.showOpenFilePicker) {
        alert("File-backed saving requires Chrome/Edge on desktop. You can still use Export/Import in Safari.");
        return;
      }
      const [handle] = await window.showOpenFilePicker({
        types: [{ description: "JSON", accept: { "application/json": [".json"] } }],
        multiple: false
      });
      fileHandle = handle;
      const file = await fileHandle.getFile();
      const text = await file.text();
      const data = JSON.parse(text || "[]");
      if (!Array.isArray(data)) throw new Error("data.json must be an array.");
      saveEntries(data.sort(byDateAsc));
      setDataSourceLabel();
      render();
    }

    async function saveDataFile() {
      if (!fileHandle) return;
      const data = loadEntries().sort(byDateAsc);
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(data, null, 2));
      await writable.close();
      setDataSourceLabel();
      alert("Saved to data.json");
    }

    async function exportJSON() {
      const data = loadEntries().sort(byDateAsc);
      const content = JSON.stringify(data, null, 2);

      // Desktop browsers (Chrome/Edge) can let you choose a folder via File System Access API.
      if (window.showSaveFilePicker) {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: "wolf-recovery-data.json",
            types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
          });
          const writable = await handle.createWritable();
          await writable.write(content);
          await writable.close();
          alert("Exported JSON backup.");
          return;
        } catch (err) {
          // user cancelled -> fall back silently
        }
      }

      // Fallback: regular download (iOS/Safari)
      const blob = new Blob([content], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "wolf-recovery-data.json";
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function toCSV(entries) {
      const headers = ["Date", "MorpheusReady", "MorpheusHRV", "OuraRecovery", "WhoopRecovery", "WhoopRHR", "OuraRHR", "Steps", "Fatigue", "Resistance", "JointWarn", "Limiter", "AMState", "PMShift", "LiftTime", "Notes"];
      const rows = [headers.join(",")];
      for (const e of entries.sort(byDateAsc)) {
        const vals = [
          e.date, e.mReady, e.mHrv, e.ouraRec, e.whoopRec, e.whoopRhr, e.ouraRhr,
          e.steps, e.fatigue, e.resistance, e.joint, (e.limiter || "AUTO"), (e.amState || ""), (e.pmShift || ""), (e.liftTime || ""), (e.notes || "").replaceAll('"', '""')
        ].map(v => (v == null ? "" : String(v)));
        vals[vals.length - 1] = `"${vals[vals.length - 1]}"`;
        rows.push(vals.join(","));
      }
      return rows.join("\n");
    }

    async function exportCSV() {
      const entries = loadEntries().sort(byDateAsc);
      const csv = toCSV(entries);

      if (window.showSaveFilePicker) {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: "wolf-recovery-data.csv",
            types: [{ description: "CSV", accept: { "text/csv": [".csv"] } }]
          });
          const writable = await handle.createWritable();
          await writable.write(csv);
          await writable.close();
          alert("Exported CSV backup.");
          return;
        } catch (err) {
          // user cancelled -> fall back silently
        }
      }

      const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "wolf-recovery-data.csv";
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function getThresholds(mode) {
      if (mode === "adt") {
        return {
          zOutlier: 1.6, rhrAbs: 6, hrvDropPct: 0.18, recDropAbs: 10, fatigueHigh: 6, fatigueLow: 4, jointWarn: 4,
          disagreementPenalty: 25, outlierPenalty: 25, fatigueMismatchPenalty: 25, trainingPenalty: 10, stepsSwingPenalty: 10
        };
      }
      return {
        zOutlier: 2.0, rhrAbs: 8, hrvDropPct: 0.22, recDropAbs: 12, fatigueHigh: 7, fatigueLow: 4, jointWarn: 5,
        disagreementPenalty: 20, outlierPenalty: 20, fatigueMismatchPenalty: 20, trainingPenalty: 8, stepsSwingPenalty: 8
      };
    }

    function computeBaselines(entries, baselineDays, todayDate) {
      const sorted = [...entries].sort(byDateAsc);
      const idx = sorted.findIndex(e => e.date === todayDate);
      const prior = (idx === -1 ? sorted : sorted.slice(0, idx));
      const window = prior.slice(Math.max(0, prior.length - baselineDays));
      const fields = ["mReady", "mHrv", "ouraRec", "whoopRec", "whoopRhr", "ouraRhr", "steps", "fatigue", "joint"];
      const base = {};
      for (const f of fields) {
        const xs = window.map(e => e[f]);
        base[f] = { mean: mean(xs), sd: sd(xs), n: xs.filter(x => x != null).length };
      }
      return base;
    }

    function classifyRecovery(entry) {
      const votes = [];
      if (entry.mReady != null) votes.push({ device: "Morpheus", signal: "mReady", score: entry.mReady });
      if (entry.ouraRec != null) votes.push({ device: "Oura", signal: "ouraRec", score: entry.ouraRec });
      if (entry.whoopRec != null) votes.push({ device: "Whoop", signal: "whoopRec", score: entry.whoopRec });
      else if (entry.whoopRhr != null) votes.push({ device: "Whoop", signal: "whoopRhrProxy", score: 120 - entry.whoopRhr });
      return votes;
    }

    function outlierFlags(entry, base, t) {
      const flags = [];
      const zflag = (field, hint) => {
        const b = base[field];
        if (!b || b.mean == null || entry[field] == null) return;
        if (!b.sd || b.sd === 0) return;
        const z = (entry[field] - b.mean) / b.sd;
        if (Math.abs(z) >= t.zOutlier) flags.push({ field, kind: "z", z, hint });
      };

      zflag("mReady", "Readiness");
      zflag("mHrv", "HRV");
      zflag("ouraRec", "Recovery");
      zflag("whoopRec", "Recovery");
      zflag("whoopRhr", "RHR");
      zflag("ouraRhr", "RHR");
      // Steps are optional; do not treat missing/0-today as a physiological outlier
      if (!(entry.date === TODAY && entry.steps === 0)) zflag("steps", "Steps");
      zflag("fatigue", "Fatigue");

      if (base.whoopRhr?.mean != null && entry.whoopRhr != null && (entry.whoopRhr - base.whoopRhr.mean) >= t.rhrAbs)
        flags.push({ field: "whoopRhr", kind: "abs", hint: `Whoop RHR +${t.rhrAbs} bpm vs baseline` });
      if (base.ouraRhr?.mean != null && entry.ouraRhr != null && (entry.ouraRhr - base.ouraRhr.mean) >= t.rhrAbs)
        flags.push({ field: "ouraRhr", kind: "abs", hint: `Oura RHR +${t.rhrAbs} bpm vs baseline` });
      if (base.mHrv?.mean != null && entry.mHrv != null) {
        const drop = (base.mHrv.mean - entry.mHrv) / base.mHrv.mean;
        if (drop >= t.hrvDropPct) flags.push({ field: "mHrv", kind: "pct", hint: `HRV drop ≥${Math.round(t.hrvDropPct * 100)}% vs baseline` });
      }
      if (base.mReady?.mean != null && entry.mReady != null && (base.mReady.mean - entry.mReady) >= t.recDropAbs)
        flags.push({ field: "mReady", kind: "abs", hint: `Readiness drop ≥${t.recDropAbs}` });
      if (base.ouraRec?.mean != null && entry.ouraRec != null && (base.ouraRec.mean - entry.ouraRec) >= t.recDropAbs)
        flags.push({ field: "ouraRec", kind: "abs", hint: `Recovery drop ≥${t.recDropAbs}` });
      if (base.whoopRec?.mean != null && entry.whoopRec != null && (base.whoopRec.mean - entry.whoopRec) >= t.recDropAbs)
        flags.push({ field: "whoopRec", kind: "abs", hint: `Recovery drop ≥${t.recDropAbs}` });
      return flags;
    }

    function computeDayAssessment(entry, entries, baselineDays, mode, _depth = 0) {
      const t = getThresholds(mode);
      const base = computeBaselines(entries, baselineDays, entry.date);
      const flags = outlierFlags(entry, base, t);
      const whyList = [];

      // Morning workflow support: if steps are 0 on today's date, treat as missing (not a true zero-step day).


      const stepsMissing = !!entry.morningEntry || (entry.steps == null);



      // ----------------------------
      // Load sequencing (anti-stacking) — ADT/CFS-friendly
      // If the TWO prior calendar days were both high-step days (>= 9500),
      // recommend a Scout day today (move, but de-stack load).
      // ----------------------------
      const HIGH_STEPS = 9500;

      function _daysDiff(aISO, bISO) {
        const a = new Date(aISO + "T00:00:00");
        const b = new Date(bISO + "T00:00:00");
        return Math.round((b - a) / (24 * 60 * 60 * 1000));
      }

      let loadStackFlag = false;
      try {
        const sortedSeq = [...entries].sort(byDateAsc);
        const i = sortedSeq.findIndex(e => e.date === entry.date);
        if (i >= 2) {
          const d1 = sortedSeq[i - 1];
          const d2 = sortedSeq[i - 2];

          const consecutive =
            (_daysDiff(d2.date, d1.date) === 1) &&
            (_daysDiff(d1.date, entry.date) === 1);

          const s1 = (d1.steps == null ? null : Number(d1.steps));
          const s2 = (d2.steps == null ? null : Number(d2.steps));

          if (consecutive && s1 != null && s2 != null && s1 >= HIGH_STEPS && s2 >= HIGH_STEPS) {
            loadStackFlag = true;
          }
        }
      } catch (e) { }
      const votes = classifyRecovery(entry);
      const voteResults = [];
      for (const v of votes) {
        let bmean = null;
        if (v.signal === "mReady") bmean = base.mReady?.mean;
        if (v.signal === "ouraRec") bmean = base.ouraRec?.mean;
        if (v.signal === "whoopRec") bmean = base.whoopRec?.mean;
        if (v.signal === "whoopRhrProxy") bmean = (base.whoopRhr?.mean != null ? 120 - base.whoopRhr.mean : null);

        let state = "neutral";
        if (bmean != null && v.score != null) {
          const delta = v.score - bmean;
          if (delta >= 2) state = "ok";
          else if (delta <= -2) state = "stressed";
        } else if (v.score != null) {
          if (v.score >= 70) state = "ok";
          else if (v.score <= 45) state = "stressed";
        }
        voteResults.push({ device: v.device, state });
      }

      const okCount = voteResults.filter(x => x.state === "ok").length;
      const stCount = voteResults.filter(x => x.state === "stressed").length;
      let majority = "mixed";
      if (okCount >= 2) majority = "ok";
      if (stCount >= 2) majority = "stressed";

      let fatigueSignal = "unknown";
      if (entry.fatigue != null) {
        if (entry.fatigue >= t.fatigueHigh) fatigueSignal = "stressed";
        else if (entry.fatigue <= t.fatigueLow) fatigueSignal = "ok";
        else fatigueSignal = "neutral";
      }

      let disagreement = (majority === "mixed") ? true : (voteResults.some(v => v.state !== "neutral" && v.state !== majority));
      // ADT/CFS nuance: Morpheus is a wake-test snapshot. If Oura + Whoop agree (OK) and only Morpheus is "stressed",
      // treat it as an AM autonomic dip rather than a true cross-device disagreement.
      const vM = voteResults.find(v => v.device === "Morpheus");
      const vO = voteResults.find(v => v.device === "Oura");
      const vW = voteResults.find(v => v.device === "Whoop");
      if (majority === "ok" && vM && vO && vW && vM.state === "stressed" && vO.state === "ok" && vW.state === "ok") {
        disagreement = false;
        whyList.push("Morpheus wake-test is low while Oura/Whoop look OK → treat as an AM autonomic dip (snapshot), not an overnight sleep signal.");
      }
      const fatigueMismatch = (fatigueSignal !== "unknown" && fatigueSignal !== "neutral" && majority !== "mixed" && fatigueSignal !== majority);

      let conf = 100;
      const outlierFieldsSet = new Set(flags.map(f => f.field));
      const outlierCount = outlierFieldsSet.size;

      // Penalize outliers, but treat "positive-direction" outliers as less alarming
      // (e.g., higher recovery, lower RHR, lower fatigue can reduce uncertainty rather than increase it).
      let outlierPenaltyTotal = 0;
      const seenOut = new Set();
      for (const f of flags) {
        if (seenOut.has(f.field)) continue;
        seenOut.add(f.field);
        let p = t.outlierPenalty;

        if (f.kind === "z") {
          const z = Number(f.z);
          const positiveDirection =
            ((f.field === "ouraRec" || f.field === "whoopRec" || f.field === "mReady" || f.field === "mHrv") && z > 0) ||
            ((f.field === "ouraRhr" || f.field === "whoopRhr") && z < 0) ||
            (f.field === "fatigue" && z < 0);

          if (positiveDirection) {
            p = Math.round(t.outlierPenalty * 0.35); // smaller penalty for "good news" outliers
          }
        }
        outlierPenaltyTotal += p;
      }

      conf -= outlierPenaltyTotal;
      if (disagreement) conf -= t.disagreementPenalty;
      if (fatigueMismatch) conf -= t.fatigueMismatchPenalty;
      if (entry.resistance === "Y") conf -= t.trainingPenalty;

      if (!stepsMissing && base.steps?.mean != null && entry.steps != null && base.steps.mean > 0) {
        const swing = Math.abs(entry.steps - base.steps.mean) / base.steps.mean;
        if (swing > 0.30) conf -= t.stepsSwingPenalty;
      }
      conf = clamp(conf, 0, 100);

      const outlierFields = new Set(flags.map(f => f.field));
      const deviceFields = { Morpheus: ["mReady", "mHrv"], Oura: ["ouraRec", "ouraRhr"], Whoop: ["whoopRec", "whoopRhr"] };
      let odd = null, oddWhy = "";
      if (majority !== "mixed" && voteResults.length >= 2) {
        const candidates = voteResults.filter(v => v.state !== "neutral" && v.state !== majority);
        if (candidates.length === 1) {
          const c = candidates[0];
          const fields = deviceFields[c.device] || [];
          const hasOutlier = fields.some(f => outlierFields.has(f));
          const disagreesWithFatigue = (fatigueSignal !== "unknown" && fatigueSignal !== "neutral" && c.state !== fatigueSignal);
          if (hasOutlier && (fatigueSignal === "unknown" || disagreesWithFatigue)) {
            odd = c.device;
            oddWhy = `Conflicts with majority (${majority}) and shows outlier behavior in ${fields.filter(f => outlierFields.has(f)).join(", ") || "device metrics"}.`;
          }
        }
      }

      let rec = "Green";
      if (conf < 55) rec = "Red";
      else if (conf < 80) rec = "Blue";

      if (entry.joint != null && entry.joint >= t.jointWarn) {
        if (rec === "Green") rec = "Blue";
        whyList.push(`Joint warning ${entry.joint}/10 → joint-protective bias.`);
      }
      if (fatigueSignal === "stressed") {
        if (rec === "Green") rec = "Blue";
        if (conf < 55) rec = "Red";
        whyList.push(`Fatigue ${entry.fatigue}/10 indicates strain.`);
      }
      if (outlierCount) whyList.push(`${outlierCount} outlier signal(s) vs baseline.`);
      if (disagreement) whyList.push(`Devices disagree → uncertainty day.`);
      if (!whyList.length) whyList.push("Stable vs baseline; devices mostly consistent.");
      // --- Integration Lag / Delayed Absorption detection (ADT/CFS-friendly) ---
      // Goal: avoid labeling a "true crash" when fatigue is not high and recent load was significant.
      // Primary Dysregulation should be reserved for days that *feel* like a crash (high fatigue / flu-like / fuses blown),
      // not for days where the system is simply integrating prior load with a 24–48h lag.
      let cycleLabel = "";
      let diurnalRebound = false;
      if (_depth === 0) {
        try {
          const sorted = entries.slice().sort(byDateAsc);
          const idx = sorted.findIndex(e => e.date === entry.date);

          // Lookback window for load memory (last 4 completed days)
          const lookback = [];
          for (let k = 1; k <= 4; k++) {
            if (idx - k >= 0) lookback.push(sorted[idx - k]);
          }

          const stepsVals = lookback
            .map(e => (e.steps == null ? null : Number(e.steps)))
            .filter(v => v != null && !isNaN(v) && v > 0);

          const highDays = stepsVals.filter(v => v >= HIGH_STEPS).length;
          const sumSteps = stepsVals.reduce((a, b) => a + b, 0);

          const recentLoad = (highDays >= 2) || (highDays >= 1 && sumSteps >= 20000);

          // A "crash-feel" proxy: very high fatigue or strong crash language in notes
          const notesTxt = String(entry.notes || "").toLowerCase();
          const crashWords = /(flu|fuses|blown|dizzy|ill|crash|can'?t move|barely|heavy|down)/;
          const crashFeel = (entry.fatigue != null && entry.fatigue >= t.fatigueHigh) || crashWords.test(notesTxt);

          // "Improving / lifting" proxy: cues that the day is not a true crash
          const liftWords = /(better|less pain|lifting|lifted|improving|ok|fine|felt good|energetic)/;
          const improving = liftWords.test(notesTxt) || (entry.fatigue != null && entry.fatigue <= (t.fatigueHigh - 2));

          // Diurnal rebound proxy (ADT/CFS pattern): rough morning but clearly "comes online" later.
          // Uses only Notes + Fatigue because the app is designed for morning entry (steps may be blank).
          const reboundWords = /(lifted|lifting|comes online|by 1pm|by 2pm|by 3pm|afternoon|evening|later.*better|energy.*good|regulated later|rebound)/;
          diurnalRebound = reboundWords.test(notesTxt) && (entry.fatigue == null || entry.fatigue <= t.fatigueHigh - 1);


          // If the devices say stressed but fatigue isn't high and recent load exists, treat as Integration Lag.
          if (mode === "adt" && majority === "stressed" && fatigueSignal !== "stressed" && recentLoad && improving) {
            cycleLabel = "Integration lag (Delayed absorption)";
          }

          // If we are stressed and clearly crash-feel, keep it as Primary Dysregulation (no cycleLabel).
          // (cycleLabel remains empty)
        } catch (e) { }
      }
      // Recommendation display text (separate from color)

      let recColor = rec; // Green/Yellow/Red
      let recText = rec;

      // Explanatory notes
      if (cycleLabel) {
        whyList.push("Pattern suggests Integration Lag / Delayed Absorption (common in ADT/CFS physiology): protect the morning and reassess later in the day.");
      }
      if (stepsMissing) {
        whyList.push("Steps not yet entered (morning entry) → steps excluded from outliers/confidence.");
      }

      // Movement guidance phrases
      const moveRoam = "Roam (easy hills OK)";
      const moveConsolidate = "Consolidate (easy / repeatable)";
      const moveScout = "Scout (de-stack load)";
      const movePrime = "Prime (gentle reset)";

      // --- Strategy (what to do) ---
      // We keep phases (REGULATED / TRANSITIONAL / INTEGRATION LAG / PROTECTIVE RESET)
      // separate from strategy (Scout / Consolidate / Expand), to reduce fear + improve decisions.
      let strategy = "Consolidate";
      let strategyLine = "";
      let plan = "";

      // Helper: choose strategy based on readiness + load memory + sequencing + joints
      const jointVal = num(entry.joint);
      const fatVal = num(entry.fatigue);
      const loadVal = 0; // loadMem is calculated after assessments in this version
      const phaseLabel = voteLabelFromAssess({ majority, fatigueSignal, cycleLabel });

      const lowJoint = (isNaN(jointVal) || jointVal <= 4);
      const lowFat = (isNaN(fatVal) || fatVal <= 4);

      // Default strategy by phase
      if (phaseLabel.startsWith("PROTECTIVE RESET")) {
        strategy = "Prime";
        strategyLine = `Prime, Don't Train — ${movePrime}`;
      } else if (phaseLabel.startsWith("INTEGRATION LAG")) {
        strategy = "Explore";
        strategyLine = `Explore (Scout) — ${moveScout}`;
        plan = "Stay in motion to maintain trust, but de-stack load. Keep it easy and boring: shorter or flatter route, conversational pace, no testing. End feeling you could do more. Reassess after ~3–5 pm.";
      } else if (phaseLabel === "TRANSITIONAL") {
        strategy = "Integrate";
        strategyLine = `Integrate (Consolidate) — ${moveConsolidate}`;
        plan = "Keep the walk easy/conversational; prefer flatter routes; avoid 'testing' the system. Let the afternoon confirm stability before adding anything.";
      } else { // REGULATED
        // Regulated can still be in integration depending on recent load.
        if (loadVal >= 0.35 || !lowJoint) {
          strategy = "Integrate";
          strategyLine = `Integrate — ${moveConsolidate}`;
          plan = "System looks harmonized. Keep rhythm: normal walk is fine, but keep intent consolidative (no testing). Hills allowed only if they feel smooth. Joint pain = stop early, shorten stride, or choose flatter route.";
        } else {
          strategy = "Expand";
          strategyLine = `Expand Carefully — ${moveRoam}`;
          plan = "System looks harmonized and cleared enough to expand a little. Walk naturally; easy hills OK if it stays smooth. Keep the finish strong (no wobble). Strength work only if joints tolerate and it improves symptoms.";
        }
      }

      // Diurnal rebound override (ADT/CFS pattern):
      // If notes indicate the system comes online later, prefer Scout/Consolidate over Prime.
      if (diurnalRebound && !phaseLabel.startsWith("PROTECTIVE RESET")) {
        if (strategy === "Prime") {
          strategy = "Explore";
          strategyLine = `Explore (Scout) — ${moveScout}`;
          plan = "Diurnal rebound noted: keep the morning gentle, but use short, easy movement to help regulation come online. Stop early. Reassess after ~3–5 pm.";
        }
      }

      // Load sequencing override: if two consecutive high-step days were stacked,
      // enforce Scout even if the system looks capable.
      if (mode === "adt" && loadStackFlag) {
        whyList.push(`Load sequencing: two consecutive high-step days (≥${HIGH_STEPS.toLocaleString()} steps) detected → Explore day to prevent delayed dysregulation.`);
        strategy = "Explore";
        strategyLine = `Explore (Scout) — ${moveScout}`;
        // Keep the stricter Explore plan, but if joints are low-risk and loadMem is low, allow a normal-length easy walk.
        plan = "Explore day: move to maintain trust, but de-stack load. Keep pace conversational; avoid pushing hills. Normal length is okay if it stays smooth; end feeling you could do more. Skip strength unless it clearly improves symptoms and joints feel safe.";
      }

      // Map strategy to the app's color families (no amber)
      recColor = (strategy === "Expand") ? "Green" : (strategy === "Prime" ? "Purple" : "Blue");
      recText = strategyLine;

      // Add a short cycle-map hint into Why (helps interpretation without extra clicks)
      const cycleMapHint = "Cycle map: Explore → Integrate → Expand. Prime is a short reset when load temporarily exceeds integration.";
      if (!whyList.includes(cycleMapHint)) whyList.push(cycleMapHint);

      // Signal Tension: capacity vs consolidation mismatch (no single faulty device)
      const highReady = flags.some(f => f.field === "mReady" && f.kind === "z" && f.z >= t.zOutlier);
      const lowOuraRec = flags.some(f => f.field === "ouraRec" && ((f.kind === "z" && f.z <= -t.zOutlier) || f.kind === "abs"));
      const tension = (!!highReady && !!lowOuraRec && !odd);
      const tensionLabel = tension ? "Capacity vs consolidation mismatch" : "";
      const tensionWhy = tension ? "Morpheus capacity unusually high while Oura recovery consolidation dropped; treat as timing/prime issue, not a faulty device." : "";
      if (tension) whyList.push("Signal Tension: capacity vs consolidation mismatch (no faulty device).");


      // --- Primary limiter (optional override) ---
      const overrideLimiter = (entry.limiter || "AUTO").toUpperCase();
      let primaryLimiterCode = "AUTO";
      let limiterWhy = "Auto-detected from symptoms, joints, and device signals.";
      if (overrideLimiter !== "AUTO") {
        primaryLimiterCode = overrideLimiter;
        limiterWhy = "Override set in the form (you can switch back to Auto anytime).";
      } else {
        const jointNum = num(entry.joint);
        const fatNum = num(entry.fatigue);
        const noteTxt = (entry.notes || "");
        const mechScore =
          (jointNum >= 6 ? 3 : jointNum >= 5 ? 2 : jointNum >= 4 ? 1 : 0) +
          (/knee|hip|sciatic|sacrum|joint|tendon|pain/i.test(noteTxt) ? 1 : 0);
        const metaScore =
          (fatNum >= 7 ? 3 : fatNum >= 6 ? 2 : fatNum >= 5 ? 1 : 0) +
          (fatigueSignal === "STRESSED" ? 1 : 0) +
          (cycleLabel.includes("DYSREGULATION") ? 2 : 0) +
          (cycleLabel.includes("INTEGRATION LAG") ? 1 : 0);

        if (mechScore >= 3 && metaScore >= 3) {
          primaryLimiterCode = "MIXED";
          limiterWhy = "Both joints and neuro-energy are signaling limits today.";
        } else if (mechScore > metaScore && mechScore >= 3) {
          primaryLimiterCode = "MECHANICAL";
          limiterWhy = "Joint/tendon signals are the tightest limiter today.";
        } else if (metaScore > mechScore && metaScore >= 3) {
          primaryLimiterCode = "METABOLIC";
          limiterWhy = "Neuro-energy / metabolic signals are the tightest limiter today.";
        } else if (mechScore >= 2 && metaScore >= 2) {
          primaryLimiterCode = "MIXED";
          limiterWhy = "Signals are mixed; treat it as a dual-limiter day.";
        } else if (mechScore >= 2) {
          primaryLimiterCode = "MECHANICAL";
          limiterWhy = "Mild joint bias today.";
        } else if (metaScore >= 2) {
          primaryLimiterCode = "METABOLIC";
          limiterWhy = "Mild neuro-energy bias today.";
        } else {
          primaryLimiterCode = "AUTO";
          limiterWhy = "No clear limiter dominates; follow the integration phase guidance.";
        }
      }

      const primaryLimiter =
        primaryLimiterCode === "MECHANICAL" ? "Mechanical (joints/tendons)" :
          primaryLimiterCode === "METABOLIC" ? "Metabolic (neuro-energy)" :
            primaryLimiterCode === "MIXED" ? "Mixed (both limiters)" :
              "Auto / none dominant";

      // Modulate the plan to match the limiter (without turning it into a centipede).
      if (primaryLimiterCode === "MECHANICAL") {
        plan = "- Joint-conserving bias: flatter route, shorter duration; avoid bending-forward && deep ROM; stop if pain rises.\n" + plan;
      } else if (primaryLimiterCode === "METABOLIC") {
        plan = "- Neuro-energy bias: keep it very easy; stop early if heaviness increases; avoid “testing” intensity.\n" + plan;
      } else if (primaryLimiterCode === "MIXED") {
        plan = "- Mixed limiter: easy pace *and* joint-conserving route; keep it boring && repeatable.\n" + plan;
      }
      return {
        flags, voteResults, majority, fatigueSignal, disagreement, fatigueMismatch, conf,
        primaryLimiter, limiterWhy,
        oddOneOut: odd, oddWhy, signalTension: tensionLabel, tensionWhy, recColor, recText, cycleLabel, why: whyList.join(" "), plan
      };

    }

    function voteLabelFromAssess(assess) {
      if (assess.cycleLabel) return "INTEGRATION LAG — Delayed Absorption";
      if (assess.majority === "ok") return "REGULATED";
      if (assess.majority === "mixed") return "TRANSITIONAL";
      if (assess.majority === "stressed") return "PROTECTIVE RESET — Protective Integration Pause";
      return String(assess.majority || "").toUpperCase();
    }

    function voteClassFromAssess(assess) {
      if (assess.cycleLabel) return "blue";
      if (assess.majority === "ok") return "green";
      if (assess.majority === "stressed") return "red";
      return "blue";
    }


    function loadMemStatusFromValue(v) {
      if (v < 2.0) return { status: "CLEARING", desc: "Reservoir low — load mostly absorbed." };
      if (v < 4.0) return { status: "INTEGRATING", desc: "Reservoir mid — integration in progress. Avoid stacking." };
      return { status: "SATURATED", desc: "Reservoir high — delayed absorption likely. Scout, don’t stack." };
    }

    function makeAnalysisBundle(entries) {
      if (!entries.length) return "No entries yet.";
      const baseDays = Number(els.baseDays.value);
      const mode = els.mode.value;
      const latest = entries.sort(byDateAsc)[entries.length - 1];
      const assess = computeDayAssessment(latest, entries, baseDays, mode);

      const lines = [];
      lines.push("ANALYSIS BUNDLE — 3-Device Cross-Check");
      lines.push(`Mode=${mode.toUpperCase()} Baseline=${baseDays}d Entries=${entries.length}`);
      lines.push(`Latest=${latest.date}`);
      lines.push(`Inputs: mReady=${fmt(latest.mReady)} mHRV=${fmt(latest.mHrv)} ouraRec=${fmt(latest.ouraRec)} whoopRec=${fmt(latest.whoopRec)} whoopRHR=${fmt(latest.whoopRhr)} ouraRHR=${fmt(latest.ouraRhr)} steps=${fmt(latest.steps)} fatigue=${fmt(latest.fatigue)} res=${latest.resistance} joint=${fmt(latest.joint)} notes="${latest.notes || ""}"`);
      lines.push("");
      const majLabel = voteLabelFromAssess(assess);
      lines.push(`Majority=${majLabel} FatigueSignal=${assess.fatigueSignal.toUpperCase()} Disagree=${assess.disagreement ? "YES" : "NO"} Conf=${assess.conf}/100`);
      lines.push(`Recommendation=${assess.recText} Plan=${assess.plan}`);
      lines.push(`OddOneOut=${assess.oddOneOut || "None"} ${assess.oddOneOut ? ("— " + assess.oddWhy) : ""}`);
      lines.push("");
      lines.push("Outliers:");
      if (!assess.flags.length) lines.push("- none");
      else assess.flags.forEach(f => lines.push(`- ${f.field}: ${f.kind === "z" ? ("z=" + fmt(f.z, 2)) : f.kind} (${f.hint || ""})`));
      lines.push("");
      lines.push("Recent (7):");
      entries.sort(byDateAsc).slice(-7).reverse().forEach(e => {
        lines.push(`- ${e.date}: mReady=${fmt(e.mReady)} mHRV=${fmt(e.mHrv)} ouraRec=${fmt(e.ouraRec)} whoopRec=${fmt(e.whoopRec)} whoopRHR=${fmt(e.whoopRhr)} ouraRHR=${fmt(e.ouraRhr)} steps=${fmt(e.steps)} fatigue=${fmt(e.fatigue)} res=${e.resistance} joint=${fmt(e.joint)} notes="${e.notes || ""}"`);
      });
      return lines.join("\n");
    }

    function computeCrashPoints(entry, baseline, prevEntry, prev2Entry) {
      const pts = { score: 0, reasons: [] };
      const fatigue = num(entry.fatigue);
      if (fatigue >= 7) { pts.score += 3; pts.reasons.push("Fatigue high (≥7)."); }
      else if (fatigue >= 6) { pts.score += 1; pts.reasons.push("Fatigue elevated (6)."); }

      const oRec = num(entry.ouraRec);
      if (!isNaN(oRec) && baseline.ouraRec && baseline.ouraRec.mean != null) {
        if (oRec <= baseline.ouraRec.mean - 10) { pts.score += 2; pts.reasons.push("Recovery consolidation lagging (Oura drop vs baseline)."); }
      }
      const oRhr = num(entry.ouraRhr);
      const wRhr = num(entry.whoopRhr);
      const rhr = !isNaN(oRhr) ? oRhr : wRhr;
      const b = baseline.ouraRhr || baseline.whoopRhr;
      if (!isNaN(rhr) && b && b.mean != null) {
        if (rhr >= b.mean + 6) { pts.score += 2; pts.reasons.push("Resting HR elevated (+6 bpm vs baseline)."); }
      }
      const hrv = num(entry.mHrv);
      if (prevEntry && prev2Entry && baseline.mHrv && baseline.mHrv.mean != null) {
        const p1 = num(prevEntry.mHrv), p2 = num(prev2Entry.mHrv);
        if (!isNaN(hrv) && !isNaN(p1) && !isNaN(p2)) {
          if ((hrv < p1) && (p1 < p2)) { pts.score += 2; pts.reasons.push("HRV trending down (2-day)."); }
        }
      }
      const s1 = prevEntry ? num(prevEntry.steps) : NaN;
      const s2 = prev2Entry ? num(prev2Entry.steps) : NaN;
      if (!isNaN(s1) && s1 >= 9500 && !isNaN(s2) && s2 >= 9500) { pts.score += 1; pts.reasons.push("Load memory active (recent high steps)."); }
      else if (!isNaN(s1) && s1 >= 11000) { pts.score += 1; pts.reasons.push("Load memory active (very high steps yesterday)."); }
      return pts;
    }

    function computeCrashSignature(entries, baselineDays) {
      if (!entries || entries.length === 0) return { label: "—", why: "Add entries to see crash signal." };
      const sorted = [...entries].sort(byDateAsc);
      const latest = sorted[sorted.length - 1];
      const baseline = computeBaselines(sorted, baselineDays, latest.date);
      const prev = sorted.length >= 2 ? sorted[sorted.length - 2] : null;
      const prev2 = sorted.length >= 3 ? sorted[sorted.length - 2] : null; // Adjusted to be safer
      const prev3 = sorted.length >= 4 ? sorted[sorted.length - 3] : null;

      const todayPts = computeCrashPoints(latest, baseline, prev, prev2);
      const yPts = prev ? computeCrashPoints(prev, baseline, prev2, prev3) : { score: 0, reasons: [] };

      const mapScale = (score) => {
        if (score <= 1) return "Stable / No Crash Signal";
        if (score <= 3) return "Vulnerable";
        if (score <= 5) return "Pre-Crash Pattern";
        if (score <= 7) return "Crash-Onset Likely";
        return "Crash State";
      };

      let label = mapScale(todayPts.score);
      const yLabel = mapScale(yPts.score);
      if ((label === "Pre-Crash Pattern" || label === "Crash-Onset Likely" || label === "Crash State") &&
        (yLabel === "Stable / No Crash Signal" || yLabel === "Vulnerable")) {
        label = "Vulnerable";
        todayPts.reasons.push("Holding at Vulnerable unless this persists tomorrow (lag-aware).");
      }
      return { label, why: todayPts.reasons.slice(0, 2).join(" ") || "No converging crash signals." };
    }

    function computeDiurnalArc(latest) {
      const am = latest?.amState || "";
      const pm = latest?.pmShift || "";
      const lt = latest?.liftTime || "";
      const amLabel = am === "FLAT" ? "Flat / heavy" : (am === "MIXED" ? "Mixed" : "Online / capable");
      const pmLabel = pm === "NO" ? "did not lift" : (pm === "SOME" ? "lifted some" : "lifted clearly");
      if (!am && !pm) return { arc: "—", why: "Add AM/PM to capture whether the system regulates later (so mornings don’t dominate the memory)." };
      let arc = (am ? amLabel : "AM ?") + " → " + (pm ? pmLabel : "PM ?");
      if (pm === "CLEAR") {
        let t = lt === "12" ? "by ~12pm" : (lt === "15" ? "by ~3pm" : (lt === "18" ? "by ~6pm" : (lt === "UNK" ? "(time unknown)" : "")));
        return { arc, why: `Regulation returned later${t ? (" " + t) : ""}. Don’t judge the day only by the morning.` };
      }
      if (pm === "SOME") return { arc, why: "Partial lift later. Scout first; let the afternoon confirm before adding load." };
      if (pm === "NO") return { arc, why: "No lift recorded. Protect tomorrow: keep today gentle and avoid stacking load." };
      return { arc, why: "PM shift not logged yet. If it lifts later, record it—this changes the story of the day." };
    }

    function computeLoadMemorySeries(entries, assessByDate) {
      const sorted = [...entries].sort(byDateAsc);
      const N = Math.min(10, sorted.length);
      const tail = sorted.slice(-N);
      const baseDays = Number(els.baseDays.value);
      const baseSlice = sorted.slice(Math.max(0, sorted.length - baseDays));
      const baseVals = baseSlice.map(e => num(e.steps)).filter(v => v > 0);
      const baseSteps = baseVals.length ? avg(baseVals) : 6500;
      const HIGH = 9500;
      const VERY = 11000;
      const contrib = [];
      for (let i = 0; i < tail.length; i++) {
        const e = tail[i];
        const s = num(e.steps);
        let c = 0;
        if (s > 0) {
          c += Math.max(0, (s - baseSteps) / 1000);
          if (s >= HIGH) c += 1.0;
          if (s >= VERY) c += 0.8;
          const prev = (i > 0) ? num(tail[i - 1].steps) : 0;
          if (prev >= HIGH && s >= HIGH) c += 0.6;
        }
        if (String(e.resistance || "").toUpperCase() === "Y") c += 0.6;
        contrib.push(c);
      }
      const mem = [];
      let m = 0;
      for (let i = 0; i < tail.length; i++) {
        const d = tail[i].date;
        const a = assessByDate ? assessByDate[d] : null;
        let clearance = 0.22;
        const vote = a ? voteLabelFromAssess(a) : "";
        if (vote.includes("INTEGRATION LAG")) clearance = 0.14;
        else if (vote.includes("TRANSITIONAL")) clearance = 0.16;
        else if (vote.includes("PROTECTIVE RESET")) clearance = 0.08;
        else if (vote.includes("REGULATED")) clearance = 0.22;
        m = Math.max(0, m * (1 - clearance) + contrib[i]);
        mem.push(m);
      }
      return { tail, baseSteps, contrib, mem };
    }

    function computeLoadMemory(entries, assessByDate) {
      if (!entries || entries.length < 2) return { label: "—", status: "—", why: "Add at least 2 days to compute Load Memory.", value: 0, series: null };
      const series = computeLoadMemorySeries(entries, assessByDate);
      const value = series.mem.length ? series.mem[series.mem.length - 1] : 0;
      const st = loadMemStatusFromValue(value);
      const label = value.toFixed(2);
      const sorted = [...entries].sort(byDateAsc);
      const last = sorted[sorted.length - 1];
      const prev = sorted[sorted.length - 2];
      const s0 = parseNum(last.steps);
      const s1 = parseNum(prev.steps);
      const HIGH = 9500;
      let whyTxt = st.desc;
      if (isNaN(s0) || s0 === 0) whyTxt = "Steps not entered for today (morning entry). Reservoir uses recent days; update steps later for sharper PEM tracking.";
      else if (!isNaN(s0) && s0 >= HIGH && !isNaN(s1) && s1 >= HIGH) whyTxt = "Two consecutive high-step days → stacking risk. Favor scouting until the reservoir drops.";
      return { label, status: st.status, why: whyTxt, value, series };
    }

    function drawLoadChart(seriesObj) {
      const canvas = document.getElementById("loadChart");
      if (!canvas || !seriesObj || !seriesObj.series) return;
      const ctx = canvas.getContext("2d");
      const { mem } = seriesObj.series;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const pad = 10;
      const w = canvas.width, h = canvas.height;
      const innerW = w - pad * 2, innerH = h - pad * 2;
      const maxV = Math.max(1, ...mem);
      const minV = 0;
      const x = (i) => pad + (mem.length === 1 ? 0 : (i / (mem.length - 1)) * innerW);
      const y = (v) => pad + innerH - ((v - minV) / (maxV - minV)) * innerH;
      ctx.strokeStyle = "#e6e8ee";
      for (let k = 0; k <= 3; k++) {
        const yy = pad + (k / 3) * innerH;
        ctx.beginPath(); ctx.moveTo(pad, yy); ctx.lineTo(pad + innerW, yy); ctx.stroke();
      }
      ctx.strokeStyle = "#111"; ctx.lineWidth = 2; ctx.beginPath();
      mem.forEach((v, i) => { const xx = x(i), yy = y(v); if (i === 0) ctx.moveTo(xx, yy); else ctx.lineTo(xx, yy); });
      ctx.stroke();
      ctx.globalAlpha = 0.08; ctx.fillStyle = "#111"; ctx.lineTo(pad + innerW, pad + innerH); ctx.lineTo(pad, pad + innerH); ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1;
      const lastX = x(mem.length - 1), lastY = y(mem[mem.length - 1]);
      ctx.fillStyle = "#111"; ctx.beginPath(); ctx.arc(lastX, lastY, 3, 0, Math.PI * 2); ctx.fill();
    }

    // ----------------------------
    // CSV Import (robust + header aliases) + status
    // ----------------------------
    function setImportStatus(msg, kind) {
      const el = document.getElementById("importStatus");
      if (!el) return;
      el.textContent = msg;
      el.style.borderColor = (kind === "ok") ? "rgba(61,220,151,.35)" : (kind === "err") ? "rgba(255,107,107,.35)" : "rgba(255,255,255,.14)";
      el.style.color = (kind === "ok") ? "rgba(61,220,151,.95)" : (kind === "err") ? "rgba(255,107,107,.95)" : "var(--muted)";
    }

    function parseCSV(text) {
      const s = String(text || "").replace(/^\uFEFF/, "");
      const rows = []; let row = []; let cur = ""; let inQ = false;
      for (let i = 0; i < s.length; i++) {
        const ch = s[i], next = s[i + 1];
        if (inQ) {
          if (ch === '"' && next === '"') { cur += '"'; i++; }
          else if (ch === '"') { inQ = false; }
          else { cur += ch; }
        } else {
          if (ch === '"') { inQ = true; }
          else if (ch === ",") { row.push(cur); cur = ""; }
          else if (ch === "\n") { row.push(cur); row = row.map(x => x.endsWith("\r") ? x.slice(0, -1) : x); rows.push(row); row = []; cur = ""; }
          else { cur += ch; }
        }
      }
      row.push(cur); row = row.map(x => x.endsWith("\r") ? x.slice(0, -1) : x);
      if (!(row.length === 1 && row[0].trim() === "")) rows.push(row);
      return rows.filter(r => r.some(c => String(c || "").trim() !== ""));
    }

    function normalizeHeader(h) {
      return String(h || "").replace(/^\uFEFF/, "").trim().toLowerCase().replace(/\s+/g, "").replace(/[^a-z0-9]/g, "");
    }

    const CSV_ALIAS_TO_KEY = {
      "date": "date", "morpheusready": "mReady", "morpheushrv": "mHrv", "mready": "mReady", "mhrv": "mHrv",
      "ourarecovery": "ouraRec", "ourarec": "ouraRec", "whooprecovery": "whoopRec", "whooprec": "whoopRec",
      "whooprhr": "whoopRhr", "ourarhr": "ouraRhr", "steps": "steps", "fatigue": "fatigue",
      "resistance": "resistance", "res": "resistance", "jointwarn": "joint", "joint": "joint",
      "limiter": "limiter", "primarylimiter": "limiter", "amstate": "amState", "pmshift": "pmShift", "lifttime": "liftTime",
      "notes": "notes", "note": "notes"
    };

    function coerceYN(v) {
      const s = String(v || "").trim().toUpperCase();
      return (s === "Y" || s === "YES" || s === "TRUE" || s === "1") ? "Y" : "N";
    }

    async function importJSON(file) {
      try {
        const text = await file.text();
        const data = JSON.parse(text || "[]");
        if (!Array.isArray(data)) throw new Error("JSON must be an array of entries.");
        saveEntries(data.sort(byDateAsc));
        render();
        alert("Imported JSON.");
      } catch (e) {
        alert("Import failed: " + (e?.message || String(e)));
      }
    }

    async function importCSV(file) {
      try {
        setImportStatus(`Importing CSV: ${file.name} ...`, "neutral");
        const txt = await file.text();
        const rows2d = parseCSV(txt);
        if (rows2d.length < 2) {
          setImportStatus("Import failed: CSV has no data rows.", "err");
          return;
        }

        const headersRaw = rows2d[0].map(h => String(h || "").trim());
        const headersNorm = headersRaw.map(normalizeHeader);
        const idx = {};
        headersNorm.forEach((hn, i) => {
          const key = CSV_ALIAS_TO_KEY[hn];
          if (key && idx[key] == null) idx[key] = i;
        });

        if (idx.date == null) {
          setImportStatus(`Import failed: missing required column "date".\nFound headers: ${headersRaw.join(", ")}`, "err");
          return;
        }

        const existing = loadEntries();
        const byDate = new Map(existing.map(r => [r.date, r]));
        let added = 0, updated = 0, skipped = 0;

        for (let i = 1; i < rows2d.length; i++) {
          const line = rows2d[i];
          const date = String(line[idx.date] ?? "").trim();
          if (!date) { skipped++; continue; }

          const row = {
            date,
            mReady: idx.mReady == null ? null : Number(line[idx.mReady]),
            mHrv: idx.mHrv == null ? null : Number(line[idx.mHrv]),
            ouraRec: idx.ouraRec == null ? null : Number(line[idx.ouraRec]),
            whoopRec: idx.whoopRec == null ? null : Number(line[idx.whoopRec]),
            whoopRhr: idx.whoopRhr == null ? null : Number(line[idx.whoopRhr]),
            ouraRhr: idx.ouraRhr == null ? null : Number(line[idx.ouraRhr]),
            steps: idx.steps == null ? null : Number(line[idx.steps]),
            fatigue: idx.fatigue == null ? null : Number(line[idx.fatigue]),
            resistance: idx.resistance == null ? "N" : coerceYN(line[idx.resistance]),
            joint: idx.joint == null ? null : Number(line[idx.joint]),
            amState: idx.amState == null ? "" : String(line[idx.amState] ?? "").trim(),
            pmShift: idx.pmShift == null ? "" : String(line[idx.pmShift] ?? "").trim(),
            liftTime: idx.liftTime == null ? "" : String(line[idx.liftTime] ?? "").trim(),
            notes: idx.notes == null ? "" : String(line[idx.notes] ?? ""),
            limiter: idx.limiter == null ? "AUTO" : String(line[idx.limiter] ?? "").toUpperCase()
          };

          Object.keys(row).forEach(k => {
            if (["date", "notes", "resistance", "amState", "pmShift", "liftTime", "limiter"].includes(k)) return;
            if (!Number.isFinite(row[k])) row[k] = null;
          });

          if (byDate.has(date)) { byDate.set(date, row); updated++; }
          else { byDate.set(date, row); added++; }
        }

        const merged = Array.from(byDate.values()).sort(byDateAsc);
        saveEntries(merged);
        render();
        setImportStatus(`CSV import complete ✅\nFile: ${file.name}\nAdded: ${added}\nUpdated: ${updated}\nSkipped (blank date): ${skipped}\nTotal entries now: ${merged.length}`, "ok");
      } catch (err) {
        setImportStatus(`Import failed: ${err?.message || String(err)}`, "err");
      }
    }

    const els = {
      date: document.getElementById("date"),
      mReady: document.getElementById("mReady"),
      mHrv: document.getElementById("mHrv"),
      ouraRec: document.getElementById("ouraRec"),
      whoopRec: document.getElementById("whoopRec"),
      whoopRhr: document.getElementById("whoopRhr"),
      ouraRhr: document.getElementById("ouraRhr"),
      steps: document.getElementById("steps"),
      morningEntry: document.getElementById("morningEntry"),
      fatigue: document.getElementById("fatigue"),
      amState: document.getElementById("amState"),
      pmShift: document.getElementById("pmShift"),
      liftTime: document.getElementById("liftTime"),
      resistance: document.getElementById("resistance"),
      joint: document.getElementById("joint"),
      limiter: document.getElementById("limiter"),
      notes: document.getElementById("notes"),
      baseDays: document.getElementById("baseDays"),
      mode: document.getElementById("mode"),
      importFileInput: document.getElementById("importFileInput"),
      importCsvInput: document.getElementById("importCsvInput")
    };

    // Morning-entry UI logic
    els.morningEntry.addEventListener('change', () => {
      els.morningEntry.dataset.userToggled = '1';
      syncMorningEntryUI();
    });
    els.date.addEventListener('change', syncMorningEntryUI);
    // Initialize defaults
    if (!els.date.value) els.date.value = TODAY;
    syncMorningEntryUI();


    function getFormEntry() {
      const date = els.date.value;
      if (!date) return null;

      // Steps are an *outcome* of the day. In the morning, leave blank.
      // If a user enters 0 on the same day (common when entering morning state), treat it as missing.


      const stepsRaw = parseNum(els.steps.value);
      const morningEntry = (els.morningEntry.checked && date === TODAY);
      // If morning entry, steps are pending and excluded until filled later
      const steps = morningEntry ? null : stepsRaw;

      return {
        date,
        mReady: parseNum(els.mReady.value),
        mHrv: parseNum(els.mHrv.value),
        ouraRec: parseNum(els.ouraRec.value),
        whoopRec: parseNum(els.whoopRec.value),
        whoopRhr: parseNum(els.whoopRhr.value),
        ouraRhr: parseNum(els.ouraRhr.value),
        steps,
        morningEntry,
        fatigue: parseNum(els.fatigue.value),
        resistance: els.resistance.value || "N",
        joint: parseNum(els.joint.value),
        limiter: (els.limiter?.value || "AUTO"),
        notes: (els.notes.value || "").trim(),
        amState: (els.amState?.value || ""),
        pmShift: (els.pmShift?.value || ""),
        liftTime: (els.liftTime?.value || "")
      };
    }

    function setFormEntry(e) {
      els.date.value = e.date || "";
      els.mReady.value = e.mReady ?? "";
      els.mHrv.value = e.mHrv ?? "";
      els.ouraRec.value = e.ouraRec ?? "";
      els.whoopRec.value = e.whoopRec ?? "";
      els.whoopRhr.value = e.whoopRhr ?? "";
      els.ouraRhr.value = e.ouraRhr ?? "";
      els.steps.value = e.steps ?? "";
      // Restore morning-entry flag only when date is today
      els.morningEntry.checked = !!e.morningEntry && (e.date === TODAY);
      els.morningEntry.dataset.userToggled = "1";
      syncMorningEntryUI();
      els.fatigue.value = e.fatigue ?? "";
      els.resistance.value = e.resistance || "N";
      els.joint.value = e.joint ?? "";
      if (els.limiter) els.limiter.value = e.limiter ?? "AUTO";
      els.notes.value = e.notes || "";
      if (els.amState) els.amState.value = e.amState || "";
      if (els.pmShift) els.pmShift.value = e.pmShift || "";
      if (els.liftTime) els.liftTime.value = e.liftTime || ""; // Added missing liftTime
    }

    function upsertEntry(newEntry) {
      const entries = loadEntries();
      const i = entries.findIndex(e => e.date === newEntry.date);
      if (i >= 0) entries[i] = newEntry; else entries.push(newEntry);
      saveEntries(entries.sort(byDateAsc));
    }

    function clearForm() {
      setFormEntry({ date: TODAY, resistance: "N" });
    }

    async function copyText(text) {
      try {
        await navigator.clipboard.writeText(text);
        alert("Copied to clipboard.");
      } catch (err) {
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
        alert("Copied to clipboard (fallback).");
      }
    }

    function setStickyOffsets() {
      const h = document.querySelector('header')?.getBoundingClientRect().height || 0;
      document.documentElement.style.setProperty('--headerH', `${Math.round(h)}px`);
    }


    function render() {
      const entries = loadEntries().sort(byDateAsc);
      document.getElementById("entryCount").textContent = String(entries.length);
      document.getElementById("baselineLabel").textContent = `${els.baseDays.value}d`;
      document.getElementById("modeLabel").textContent = els.mode.value === "adt" ? "ADT" : "Standard";
      const latest = entries.length ? entries[entries.length - 1] : null;

      if (latest) {
        const bd = Number(els.baseDays.value), m = els.mode.value;
        const assess = computeDayAssessment(latest, entries, bd, m);

        document.getElementById("todayRec").textContent = assess.recText;
        const vtxt = voteLabelFromAssess(assess);
        const vEl = document.getElementById("todayVote");
        if (vEl) {
          const phaseClass = assess.cycleLabel ? "phase-lag" : (assess.majority === "ok" ? "phase-regulated" : (assess.majority === "mixed" ? "phase-transitional" : "phase-reset"));
          vEl.innerHTML = vtxt ? `<span class="phasePill ${phaseClass}">${escapeHTML(vtxt)}</span>` : "—";
        }

        document.getElementById("fatigueSig").textContent = (assess.fatigueSignal === "ok" ? "Online / Capable" : (assess.fatigueSignal === "stressed" ? "Flat / Heavy (Neuro‑energy low)" : "Mixed / Variable"));
        document.getElementById("fatigueDetail").textContent = `Fatigue rating: ${latest.fatigue ?? "—"}/10`;
        document.getElementById("fatigueWhy").textContent = (assess.fatigueSignal === "ok" ? "Neuro‑energy is available. Still respect load memory + joints." : (assess.fatigueSignal === "stressed" ? "Neuro‑energy hasn’t come online yet. Morning protection + reassess later." : "Mixed signal. Scout early; if you lift by 3–5pm, resume a normal easy walk."));

        setTodayWhyBullets(`${assess.why} Plan: ${assess.plan}`);
        document.getElementById("todayConf").textContent = String(assess.conf);
        document.getElementById("oddOneOut").textContent = assess.oddOneOut || "—";
        document.getElementById("oddWhy").textContent = assess.oddOneOut ? assess.oddWhy : "No single device is the lone contradiction today.";
        document.getElementById("signalTension").textContent = assess.signalTension || "—";
        document.getElementById("tensionWhy").textContent = assess.tensionWhy || "—";

        document.getElementById("primaryLimiter").textContent = assess.primaryLimiter || "Auto / none dominant";
        document.getElementById("limiterWhy").textContent = assess.limiterWhy || "—";

        const cs = computeCrashSignature(entries, bd);
        document.getElementById("crashSig").textContent = cs.label || "—";
        document.getElementById("crashWhy").textContent = cs.why || "—";

        const assessByDate = {};
        for (const e of entries) {
          assessByDate[e.date] = computeDayAssessment(e, entries, bd, m, 1);
        }

        const lm = computeLoadMemory(entries, assessByDate);
        document.getElementById("loadMem").textContent = lm.label || "—";
        document.getElementById("loadMemStatus").textContent = lm.status || "—";
        document.getElementById("loadWhy").textContent = lm.why || "—";
        drawLoadChart(lm);

        const da = computeDiurnalArc(latest);
        document.getElementById("diurnalArc").textContent = da.arc || "—";
        document.getElementById("diurnalWhy").textContent = da.why || "—";
      } else {
        ["todayRec", "todayVote", "fatigueSig", "fatigueDetail", "fatigueWhy", "todayConf", "oddOneOut", "oddWhy", "signalTension", "tensionWhy", "crashSig", "crashWhy", "loadMem", "loadMemStatus", "loadWhy", "diurnalArc", "diurnalWhy"].forEach(id => {
          const el = document.getElementById(id); if (el) el.textContent = "—";
        });
        setTodayWhyBullets("Add an entry to see guidance.");
      }

      const tbody = document.querySelector("#tbl tbody");
      tbody.innerHTML = "";
      for (const e of entries.slice().reverse()) {
        const assess = computeDayAssessment(e, entries, Number(els.baseDays.value), els.mode.value);
        const outlierFields = [...new Set(assess.flags.map(f => f.field))];
        const recClass = assess.recColor.toLowerCase();
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="mono">${e.date}</td>
          <td><span class="tag ${voteClassFromAssess(assess)}">${voteLabelFromAssess(assess)}</span></td>
          <td class="mono">${outlierFields.length ? outlierFields.join(", ") : "—"}</td>
          <td class="mono">${assess.conf}</td>
          <td><span class="tag ${recClass}">${assess.recText}</span></td>
          <td class="muted">${String(e.notes || "").slice(0, 60)}${(e.notes || "").length > 60 ? "…" : ""}</td>
        `;
        tr.style.cursor = "pointer";
        tr.addEventListener("click", () => setFormEntry(e));
        tbody.appendChild(tr);
      }
    }

    // --- Initialization & Listeners ---
    els.baseDays.addEventListener("change", render);
    els.mode.addEventListener("change", render);

    document.getElementById("openFileBtn").addEventListener("click", async () => {
      try { await openDataFile(); } catch (e) { alert("Open failed."); }
    });
    document.getElementById("saveFileBtn").addEventListener("click", async () => {
      try { await saveDataFile(); } catch (e) { alert("Save failed."); }
    });
    document.getElementById("exportJsonBtn").addEventListener("click", exportJSON);
    document.getElementById("exportCsvBtn").addEventListener("click", exportCSV);

    document.getElementById("addBtn").addEventListener("click", () => {
      const e = getFormEntry(); if (!e) return alert("Pick a date.");
      upsertEntry(e); render();
      if (fileHandle) saveDataFile();
    });

    document.getElementById("clearBtn").addEventListener("click", clearForm);
    document.getElementById("bundleBtn").addEventListener("click", () => copyText(makeAnalysisBundle(loadEntries())));
    document.getElementById("resetBtn").addEventListener("click", () => {
      if (confirm("Delete all data?")) { localStorage.removeItem(LS_KEY); render(); }
    });

    document.getElementById("importJsonBtn").addEventListener("click", () => {
      els.importFileInput.value = "";
      els.importFileInput.click();
    });
    els.importFileInput.addEventListener("change", (e) => {
      const file = e.target.files?.[0];
      if (file) importJSON(file);
    });

    document.getElementById("importCsvBtn").addEventListener("click", () => {
      els.importCsvInput.value = "";
      els.importCsvInput.click();
    });
    els.importCsvInput.addEventListener("change", (e) => {
      const file = e.target.files?.[0];
      if (file) importCSV(file);
    });

    window.addEventListener("resize", setStickyOffsets);
    window.addEventListener("orientationchange", () => setTimeout(setStickyOffsets, 50));

    if (!els.date.value) els.date.value = TODAY;
    setStickyOffsets();
    render();
  </script>

  <div class="rec-legend">
    <h4>Movement Guidance (ADT / CFS)</h4>
    <ul>
      <li><strong>Maintain Rhythm — Go Wolf:</strong> Full walk. Natural pace. Hills allowed. Movement is the regulator.
      </li>
      <li><strong>Modulate & Observe — Stay in Motion:</strong> Full walk, gentler. End better than you started.</li>
      <li><strong>Morning Protection — Prime, Don’t Train:</strong> Short (10–30 min). Flat, slow, exploratory only.
      </li>
      <li><strong>Restore First — Movement Only If Regulating:</strong> Very short or none. Stability before motion.
      </li>
    </ul>
  </div>
</body>

</html>