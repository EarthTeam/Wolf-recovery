<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wolf Recovery — v26.4 (Integration Phase Language + Harmonized Colors)</title>
  <style>
    :root{
      --headerH: 0px;
     --pad: 12px; --radius: 14px; }
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background:#f6f7f9; color:#111; }
    header { padding: 18px 16px; background:#fff; border-bottom:1px solid #e6e8ee; position: sticky; top:0; z-index:10; }
    header h1 { margin:0; font-size: 18px; }
    header .sub { margin-top:6px; color:#555; font-size: 13px; line-height:1.3; }
    main { padding: 16px; max-width: 1160px; margin: 0 auto; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 980px){ .grid { grid-template-columns: 430px 1fr; align-items:start; } }
    .card { background:#fff; border:1px solid #e6e8ee; border-radius: var(--radius); padding: 14px; }
    .card h2 { margin: 0 0 10px; font-size: 15px; }
    label { display:block; font-size: 12px; color:#333; margin: 10px 0 6px; }
    input, select, textarea { width:100%; padding: 10px; border-radius: 10px; border:1px solid #d7dbe6; background:#fff; font-size: 14px; box-sizing:border-box; }
    textarea { min-height: 64px; resize: vertical; }
    .row2 { display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; }
    .btnrow { display:flex; flex-wrap:wrap; gap: 8px; margin-top: 12px; }
    button { border:1px solid #d7dbe6; background:#111; color:#fff; padding:10px 12px; border-radius: 10px; font-weight: 650; cursor:pointer; }
    button.secondary { background:#fff; color:#111; }
    button.danger { background:#b00020; border-color:#b00020; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { display:inline-flex; align-items:center; gap:6px; border:1px solid #d7dbe6; padding: 6px 10px; border-radius: 999px; font-size: 12px; color:#222; background:#fff; }
    .pillRow { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }

    .phasePill{ display:inline-block; padding: 6px 10px; border-radius: 999px; font-weight: 700; font-size: 12px; border:1px solid #d7dbe6; background:#fff; color:#111; }
    .phase-regulated{ background:#e7f6ec; border-color:#b8e0c4; }
    .phase-lag{ background:#e7f0ff; border-color:#b8cdfa; }
    .phase-transitional{ background:#f1eaff; border-color:#d0c2ff; }
    .phase-reset{ background:#fde8e8; border-color:#f5b4b4; }

    .kpi { display:grid; grid-template-columns: repeat(12, 1fr); gap: 12px; margin-top: 10px; }
    .kpi .box { border:1px solid #e6e8ee; border-radius: 12px; padding: 10px; background:#fcfcfd; }

/* KPI layout */
.recBox{ grid-column: span 6; }
.miniBox{ grid-column: span 3; }
.crashBox{ grid-column: span 4; }
.loadBox{ grid-column: span 4; }
.fatigueBox{ grid-column: span 4; }
.tensionBox{ grid-column: span 4; }
.diurnalBox{ grid-column: span 4; }

.val.big{ font-size: 18px; line-height: 1.25; font-weight: 750; }
.whyBullets{ margin-top: 8px; }
.whyBullets ul{ margin: 8px 0 0 18px; padding: 0; }
.sub{ margin-top: 4px; color:#4b5563; font-size: 12.5px; }
.micro{ margin-top: 6px; color:#6b7280; font-size: 12px; line-height: 1.25; }
.crashBox{ background: #fff7ed; border-color: #fed7aa; }
.fatigueBox{ background: #f8fafc; }
.tensionBox{ background: #f8fafc; }
.diurnalBox{ background: #f0fdf4; border-color: #bbf7d0; }

@media (max-width: 980px){
  .recBox{ grid-column: span 12; }
  .miniBox{ grid-column: span 4; }
  .crashBox,.fatigueBox,.tensionBox,.diurnalBox{ grid-column: span 6; }
}
@media (max-width: 680px){
  .miniBox,.crashBox,.fatigueBox,.tensionBox,.diurnalBox{ grid-column: span 12; }
}

    .kpi .box .lbl { font-size: 11px; color:#555; }
    .kpi .box .val { font-size: 18px; font-weight: 760; margin-top: 4px; }
    .kpi .box .hint { font-size: 11px; color:#666; margin-top: 4px; line-height:1.2; }
    table { width:100%; border-collapse: separate; border-spacing: 0; font-size: 12px; }
    th, td { padding: 8px 8px; border-bottom:1px solid #eef0f6; vertical-align: top; }
    th { text-align:left; color:#444; font-weight: 700; position: sticky; top: calc(var(--headerH) + env(safe-area-inset-top)); background:#fff; z-index: 5; }
    tr:hover td { background:#fbfbff; }
    .tag { display:inline-block; padding: 2px 8px; border-radius: 999px; font-size: 11px; border:1px solid #d7dbe6; background:#fff; }
    .green { border-color:#1b7f3b; color:#1b7f3b; }
    .blue { border-color:#1f5fbf; color:#1f5fbf; }
    .yellow { border-color:#b07a00; color:#b07a00; }
    .red { border-color:#b00020; color:#b00020; }
    .muted { color:#666; }
    .small { font-size: 11px; color:#666; line-height:1.2; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .hr { height:1px; background:#eef0f6; margin: 12px 0; }
    .flex { display:flex; gap: 10px; flex-wrap:wrap; align-items:center; }
    .right { margin-left:auto; }
    .note { background:#f0f4ff; border:1px solid #d8e2ff; padding: 10px; border-radius: 12px; font-size: 12px; color:#203a86; line-height:1.35; }
    .warn { background:#fff8e6; border:1px solid #ffe1a6; padding: 10px; border-radius: 12px; font-size: 12px; color:#6b4a00; line-height:1.35; }
  
    header .hdrRow{ display:flex; gap:14px; align-items:flex-start; justify-content:space-between; }
    header .hdrLeft{ min-width: 0; }
    header .hdrControls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .btn{ appearance:none; border:1px solid #d6d9e2; background:#fff; border-radius: 12px; padding: 8px 10px; font-size:12px; cursor:pointer; }
    .btn:hover{ background:#f3f4f7; }
    .toggle{ display:flex; gap:8px; align-items:center; font-size:12px; color:#333; user-select:none; }
    .toggle input{ transform: translateY(1px); }
    .pill{ display:inline-block; margin-left:8px; font-size:11px; padding:3px 8px; border-radius:999px; border:1px solid #d6d9e2; background:#f7f8fb; color:#333; }
    .pill.exp{ border-color:#c7d2fe; background:#eef2ff; }
    .modalOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:999; padding:18px; }
    .modal{ width:min(760px, 100%); background:#fff; border-radius:16px; border:1px solid #e6e8ee; box-shadow:0 12px 32px rgba(0,0,0,.18); padding:14px; }
    .modal h3{ margin:0 0 8px; font-size:14px; }
    .modal .closeRow{ display:flex; justify-content:space-between; gap:10px; align-items:center; }
    .modal .log{ margin-top:10px; max-height: 62vh; overflow:auto; padding-right:6px; }
    .logItem{ border-top:1px solid #eef0f5; padding:10px 0; }
    .logItem:first-child{ border-top:none; padding-top:0; }
    .logItem .ver{ font-weight:600; }
    .logItem ul{ margin:6px 0 0 18px; padding:0; }

  </style>
</head>
<body>
<header>
  <div class="hdrRow">
    <div class="hdrLeft">
      <h1>Wolf Recovery <span class="muted" id="appVersion">v26.4</span> <span class="pill" id="channelPill">Stable</span></h1>
      <div class="sub">
        Local-first app (single-file). Can store data in browser storage, or in a real <span class="mono">data.json</span> file (recommended), and later sync to Supabase.
      </div>
    </div>
    <div class="hdrControls">
      <button class="btn" id="btnChangelog" type="button" title="See what's changed">Changelog</button>
      <label class="toggle" title="Experimental branch: changes analysis knobs; keep backups">
        <input type="checkbox" id="chkExperimental">
        <span>Experimental</span>
      </label>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <section class="card">
      <h2>Data Location</h2>
      <div class="note">
        <div><b>Current source:</b> <span id="dataSource" class="mono">localStorage</span></div>
        <div class="small">Recommended: open a <span class="mono">data.json</span> file once, then use “Save to File” so your data lives in your folder.</div>
      </div>

      <div class="btnrow" style="margin-top:10px">
        <button id="openFileBtn" class="secondary">Open data.json</button>
        <button id="saveFileBtn" class="secondary" disabled>Save to File</button>
        <button id="exportJsonBtn" class="secondary">Export JSON</button>
        <button id="importJsonBtn" class="secondary">Import JSON</button>
        <button id="exportCsvBtn" class="secondary">Export CSV</button>
        <button id="importCsvBtn">Import CSV</button>
        <input id="importCsvInput" type="file" accept=".csv,text/csv" style="display:none" />
      </div>

      <input id="importFileInput" type="file" accept="application/json" style="display:none" />

      <div class="hr"></div>

      <h2>Daily Entry</h2>

      <label for="date">Date</label>
      <input id="date" type="date" />

      <div class="hr"></div>

      <h2 style="margin-top:0">Device Metrics</h2>

      
      <h2 style="margin-top:0">Device Metrics</h2>

      <div class="row3">
        <div>
          <label for="mReady">Morpheus Morning Readiness (%) <span class="small muted">(wake HRV test)</span></label>
          <input id="mReady" type="number" step="1" min="0" max="100" />
        </div>
        <div>
          <label for="mHrv">Morpheus HRV</label>
          <input id="mHrv" type="number" step="1" min="0" />
        </div>
        <div>
          <label for="whoopRec">Whoop Recovery (0–100) (optional)</label>
          <input id="whoopRec" type="number" step="1" min="0" max="100" />
        </div>
      </div>
      <div class="small muted" style="margin:-6px 0 10px 0">
        Morpheus is a <b>morning snapshot</b> (your 2–3 min HRV check after waking). It does <b>not</b> measure overnight sleep; a low score can reflect an AM autonomic dip even after a decent night.
      </div>

      <div class="row3">
        <div>
          <label for="ouraRec">Oura Recovery (0–100)</label>
          <input id="ouraRec" type="number" step="1" min="0" max="100" />
        </div>
        <div>
          <label for="whoopRhr">Whoop RHR (bpm)</label>
          <input id="whoopRhr" type="number" step="1" min="0" />
        </div>
        <div>
          <label for="ouraRhr">Oura RHR (bpm)</label>
          <input id="ouraRhr" type="number" step="1" min="0" />
        </div>
      </div>


      <div class="row2">
        <div>
          <label for="steps">Steps (optional — fill later, after the day)</label>
          <input id="steps" type="number" step="1" min="0" placeholder="Leave blank in the morning" />
          <div class="small" style="margin-top:6px">
            <label style="display:flex; gap:8px; align-items:center; margin:0">
              <input id="morningEntry" type="checkbox" style="width:auto; margin:0" />
              <span><b>Morning entry (steps pending)</b> — exclude steps from today’s Vote/Outliers until you fill them later.</span>
            </label>
          </div>
        </div>
        <div>
          <label for="fatigue">Fatigue (1–10)</label>
          <input id="fatigue" type="number" step="1" min="1" max="10" />
        </div>
      </div>

      <div class="row2">
        <div>
          <label for="amState">AM State (how you woke up)</label>
          <select id="amState">
            <option value="">—</option>
            <option value="FLAT">Flat / Heavy</option>
            <option value="MIXED">Mixed</option>
            <option value="ONLINE">Online / Capable</option>
          </select>
        </div>
        <div>
          <label for="pmShift">PM Shift (did it lift later?)</label>
          <select id="pmShift">
            <option value="">—</option>
            <option value="NO">Did not lift</option>
            <option value="SOME">Lifted some</option>
            <option value="CLEAR">Lifted clearly</option>
          </select>
        </div>
      </div>

      <div class="row2">
        <div>
          <label for="liftTime">Lift time (optional)</label>
          <select id="liftTime">
            <option value="">—</option>
            <option value="12">By ~12pm</option>
            <option value="15">By ~3pm</option>
            <option value="18">By ~6pm</option>
            <option value="UNK">Unknown</option>
          </select>
        </div>
        <div class="small muted" style="align-self:end; padding-bottom:6px">
          Quick CFS/ADT nuance: this captures the “half-full” part of the day if the system regulates later.
        </div>
      </div>


      <div class="row2">
        <div>
          <label for="resistance">Resistance Session?</label>Resistance Session?</label>
          <select id="resistance">
            <option value="N">No</option>
            <option value="Y">Yes</option>
          </select>
        </div>
        <div>
          <label for="joint">Joint/Tendon Warning (0–10)</label>
          <input id="joint" type="number" step="1" min="0" max="10" />
        </div>
        <div>
          <label for="limiter">Primary Limiter (optional)</label>
          <select id="limiter">
            <option value="AUTO">Auto (detect)</option>
            <option value="METABOLIC">Metabolic / neuro-energy</option>
            <option value="MECHANICAL">Mechanical / joints</option>
            <option value="MIXED">Mixed</option>
          </select>
        </div>
      </div>

      <label for="notes">Notes</label>
      <textarea id="notes" placeholder="sleep disruptions, meds timing, illness symptoms, travel, etc."></textarea>

      <div class="hr"></div>

      <div class="row2">
        <div>
          <label for="baseDays">Baseline window (days)</label>
          <select id="baseDays">
            <option value="7">7</option>
            <option value="10">10</option>
            <option value="14" selected>14</option>
            <option value="21">21</option>
          </select>
        </div>
        <div>
          <label for="mode">Guardrail Mode</label>
          <select id="mode">
            <option value="standard">Standard</option>
            <option value="adt" selected>ADT / joint-protective</option>
          </select>
        </div>
      </div>

      <div class="btnrow">
        <button id="addBtn">Add / Update Day</button>
        <button id="clearBtn" class="secondary">Clear Form</button>
        <button id="bundleBtn" class="secondary">Copy Analysis Bundle</button>
        <button id="resetBtn" class="danger">Reset All Data</button>
      </div>

      <div class="warn" style="margin-top:12px">
        Decision-support only, not diagnosis. If you have concerning symptoms, seek medical care.
      </div>
    </section>

    <section class="card">
      <div class="flex">
        <h2 style="margin:0">Dashboard</h2>
        <span class="pill right"><span class="muted">Entries:</span> <span id="entryCount" class="mono">0</span></span>
        <span class="pill"><span class="muted">Baseline:</span> <span id="baselineLabel" class="mono">14d</span></span>
        <span class="pill"><span class="muted">Mode:</span> <span id="modeLabel" class="mono">ADT</span></span>
      </div>

      <div class="kpi">
  <div class="box recBox">
    <div class="lbl">Today's Recommendation</div>
    <div class="val big" id="todayRec">—</div>
    <div class="whyBullets" id="todayWhy">—</div>
  </div>

  <div class="box miniBox">
    <div class="lbl">Current Integration Phase</div>
    <div class="val" id="todayVote">—</div>
    <div class="hint">System-wide phase based on combined device signals, symptoms, and recent load.</div>
  </div>

  <div class="box miniBox">
    <div class="lbl">Primary Limiter</div>
    <div class="val" id="primaryLimiter">—</div>
    <div class="hint" id="limiterWhy">Metabolic (neuro-energy), Mechanical (joints/tendons), or Mixed. You can override this in the form.</div>
  </div>

  <div class="box miniBox">
    <div class="lbl">Confidence</div>
    <div class="val" id="todayConf">—</div>
    <div class="hint">Higher = stronger agreement + fewer outliers.</div>
  </div>

  <div class="box miniBox">
    <div class="lbl">Odd-One-Out Device</div>
    <div class="val" id="oddOneOut">—</div>
    <div class="hint" id="oddWhy">—</div>
  </div>

  <div class="box crashBox">
    <div class="lbl">Integration Stress Signature (24–72h)</div>
    <div class="val" id="crashSig">—</div>
    <div class="hint" id="crashWhy">—</div>
  </div>

  <div class="box loadBox">
    <div class="lbl">Load Memory (PEM Reservoir)</div>
    <div class="val" id="loadMem">—</div>
    <div class="sub" id="loadMemStatus">—</div>
    <div class="pillRow">
      <span class="pill" id="capacityFlagPill" style="display:none"></span>
      <span class="pill" id="clearancePill" style="display:none"></span>
    </div>
    <canvas id="loadChart" width="520" height="120" style="width:100%; height:120px; margin-top:8px; border-radius:12px; background:#fff;"></canvas>
    <div class="hint" id="loadWhy">Shows unabsorbed movement-load over the last 7–10 days. Rising/plateau = integration load still in process; falling = clearing.</div>
  </div>

  <div class="box fatigueBox">
    <div class="lbl">Neuro‑Energy (Fatigue)</div>
    <div class="val" id="fatigueSig">—</div>
    <div class="sub" id="fatigueDetail">—</div>
    <div class="hint" id="fatigueWhy">—</div>
  </div>

  <div class="box tensionBox">
    <div class="lbl">Signal Tension</div>
    <div class="val" id="signalTension">—</div>
    <div class="micro">What it means: signals point in different directions (often “capacity vs consolidation”). Not automatically a faulty device.</div>
    <div class="hint" id="tensionWhy">—</div>
  </div>

  <div class="box diurnalBox">
    <div class="lbl">Diurnal Arc (AM → PM)</div>
    <div class="val" id="diurnalArc">—</div>
    <div class="hint" id="diurnalWhy">—</div>
  </div>
</div>
      <div class="hr"></div>

      <h2>Entries</h2>
      <div class="small">Tap a row to load it into the form for editing.</div>

      <div style="overflow:auto; max-height: 560px; margin-top:10px;">
        <table id="tbl">
          <thead>
            <tr>
              <th>Date</th>
              <th>Vote</th>
              <th>Outliers</th>
              <th>Conf</th>
              <th>Rec</th>
              <th class="muted">Notes</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </div>

  <div class="modalOverlay" id="changelogOverlay" role="dialog" aria-modal="true" aria-label="Changelog">
    <div class="modal">
      <div class="closeRow">
        <h3>Changelog</h3>
        <button class="btn" id="btnCloseChangelog" type="button">Close</button>
      </div>
      <div class="note" style="margin-top:6px;">
        <b>Stable</b> keeps conservative defaults. <b>Experimental</b> tries different knobs (e.g., load sequencing and clearance behavior).
        Export JSON backups before switching.
      </div>
      <div class="log" id="changelogList"></div>
    </div>
  </div>

</main>

<script>

  // ---------------------------
  // Version + branch controls
  // ---------------------------
  const APP_VERSION = "v26.4";
  const LS_EXPERIMENTAL = "wolfRecovery_experimental";
  const CHANGELOG = [
    { ver: "v26.4", items: [
      "Added in-app changelog panel.",
      "Added Stable / Experimental branch toggle (stored locally).",
      "Experimental branch is for testing; export backups before switching."
    ]},
    { ver: "v26.3", items: [
      "Load approaching capacity flag + clearance framing.",
      "Bias for ADT/CFS timing and load sequencing."
    ]}
  ];

  function isExperimental(){ return localStorage.getItem(LS_EXPERIMENTAL) === "1"; }
  function setExperimental(on){ localStorage.setItem(LS_EXPERIMENTAL, on ? "1" : "0"); }

  function renderChangelog(){
    const list = document.getElementById("changelogList");
    if (!list) return;
    list.innerHTML = CHANGELOG.map(x => {
      const li = x.items.map(i => `<li>${escapeHTML(i)}</li>`).join("");
      return `<div class="logItem"><div class="ver">${escapeHTML(x.ver)}</div><ul>${li}</ul></div>`;
    }).join("");
  }
  function openChangelog(){ renderChangelog(); const ov=document.getElementById("changelogOverlay"); if (ov) ov.style.display="flex"; }
  function closeChangelog(){ const ov=document.getElementById("changelogOverlay"); if (ov) ov.style.display="none"; }

  function syncHeaderUI(){
    const v=document.getElementById("appVersion"); if (v) v.textContent = APP_VERSION;
    const pill=document.getElementById("channelPill");
    const chk=document.getElementById("chkExperimental");
    const exp=isExperimental();
    if (chk) chk.checked = exp;
    if (pill){
      pill.textContent = exp ? "Experimental" : "Stable";
      pill.classList.toggle("exp", exp);
    }
  }


  function escapeHTML(str){
    return String(str ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");
  }



  function num(x, fallback=0){
    const n = (typeof x === "number") ? x : parseFloat(String(x ?? "").trim());
    return Number.isFinite(n) ? n : fallback;
  }

  function setTodayWhyBullets(text){
    const el = document.getElementById("todayWhy");
    if (!el) return;
    const raw = String(text||"").trim();
    if (!raw){ el.innerHTML = "<li>—</li>"; return; }
    // split on semicolons or sentence boundaries
    let parts = raw.split(";").map(s=>s.trim()).filter(Boolean);
    if (parts.length===1){
      parts = raw.split(/\. +/).map(s=>s.trim()).filter(Boolean);
    }
    if (parts.length===0) parts = [raw];
    // ensure li wrapper (works whether todayWhy is ul or div)
    el.innerHTML = parts.map(p=>`<li>${escapeHTML(p.replace(/\.$/,""))}.</li>`).join("");
  }

  const LS_KEY = "three_device_recovery_entries_v2";
  let fileHandle = null;

  function loadEntries(){ try { return JSON.parse(localStorage.getItem(LS_KEY) || "[]"); } catch { return []; } }
  // CSV import uses these aliases
  function loadRows(){ return loadEntries(); }
  function saveRows(arr){ saveEntries(arr); }
  function saveEntries(arr){ localStorage.setItem(LS_KEY, JSON.stringify(arr)); }
  function byDateAsc(a,b){ return (a.date||"").localeCompare(b.date||""); }
  function parseNum(v){ if (v === "" || v == null) return null; const x = Number(v); return Number.isFinite(x) ? x : null; }
  function avg(arr){ if(!arr || !arr.length) return 0; let s=0, c=0; for(const v of arr){ const x=Number(v); if(Number.isFinite(x)){ s+=x; c++; } } return c? (s/c):0; }
  function fmt(n, d=0){ if (n == null || Number.isNaN(n)) return ""; const x = Number(n); return Number.isFinite(x) ? x.toFixed(d) : ""; }
  function mean(xs){ const a = xs.filter(x=>x!=null && Number.isFinite(x)); if (!a.length) return null; return a.reduce((p,c)=>p+c,0)/a.length; }
  function sd(xs){ const a = xs.filter(x=>x!=null && Number.isFinite(x)); if (a.length < 2) return null; const m=mean(a); const v=a.reduce((p,c)=>p+(c-m)*(c-m),0)/(a.length-1); return Math.sqrt(v); }
  function clamp(x,lo,hi){ return Math.max(lo, Math.min(hi, x)); }

  const TODAY = new Date().toISOString().slice(0,10);

  function syncMorningEntryUI(){
    if (!window.els) return;
    const d = els.date.value || TODAY;
    const isToday = (d === TODAY);
    // Default: if date is today, assume morning entry unless user explicitly turned it off
    if (isToday && els.morningEntry.checked === false && els.morningEntry.dataset.userToggled !== "1"){
      els.morningEntry.checked = true;
    }
    if (!isToday){
      els.morningEntry.checked = false;
      els.morningEntry.dataset.userToggled = "0";
    }
    const pending = els.morningEntry.checked && isToday;
    els.steps.disabled = pending;
    if (pending){
      els.steps.value = "";
    }
  }

  function setDataSourceLabel(){
    const el = document.getElementById("dataSource");
    el.textContent = fileHandle ? "data.json (file-backed)" : "localStorage";
    document.getElementById("saveFileBtn").disabled = !fileHandle;
  }

  async function openDataFile(){
    if (!window.showOpenFilePicker){
      alert("File-backed saving requires Chrome/Edge on desktop. You can still use Export/Import in Safari.");
      return;
    }
    const [handle] = await window.showOpenFilePicker({
      types: [{ description: "JSON", accept: { "application/json": [".json"] } }],
      multiple: false
    });
    fileHandle = handle;
    const file = await fileHandle.getFile();
    const text = await file.text();
    const data = JSON.parse(text || "[]");
    if (!Array.isArray(data)) throw new Error("data.json must be an array.");
    saveEntries(data.sort(byDateAsc));
    setDataSourceLabel();
    render();
  }

  async function saveDataFile(){
    if (!fileHandle) return;
    const data = loadEntries().sort(byDateAsc);
    const writable = await fileHandle.createWritable();
    await writable.write(JSON.stringify(data, null, 2));
    await writable.close();
    setDataSourceLabel();
    alert("Saved to data.json");
  }

  async function exportJSON(){
    const data = loadEntries().sort(byDateAsc);
    const content = JSON.stringify(data, null, 2);

    // Desktop browsers (Chrome/Edge) can let you choose a folder via File System Access API.
    if (window.showSaveFilePicker){
      try{
        const handle = await window.showSaveFilePicker({
          suggestedName: "wolf-recovery-data.json",
          types: [{ description: "JSON", accept: {"application/json":[".json"]} }]
        });
        const writable = await handle.createWritable();
        await writable.write(content);
        await writable.close();
        alert("Exported JSON backup.");
        return;
      }catch(err){
        // user cancelled -> fall back silently
      }
    }

    // Fallback: regular download (iOS/Safari)
    const blob = new Blob([content], { type:"application/json" });
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download="wolf-recovery-data.json";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function toCSV(entries){
    const headers=["Date","MorpheusReady","MorpheusHRV","OuraRecovery","WhoopRecovery","WhoopRHR","OuraRHR","Steps","Fatigue","Resistance","JointWarn","Limiter","AMState","PMShift","LiftTime","Notes"];
    const rows=[headers.join(",")];
    for (const e of entries.sort(byDateAsc)){
      const vals=[
        e.date, e.mReady, e.mHrv, e.ouraRec, e.whoopRec, e.whoopRhr, e.ouraRhr,
        e.steps, e.fatigue, e.resistance, e.joint, (e.limiter||"AUTO"), (e.amState||""), (e.pmShift||""), (e.liftTime||""), (e.notes||"").replaceAll('"','""')
      ].map(v => (v==null?"":String(v)));
      vals[vals.length-1] = `"${vals[vals.length-1]}"`;
      rows.push(vals.join(","));
    }
    return rows.join("\n");
  }

  async function exportCSV(){
    const entries=loadEntries().sort(byDateAsc);
    const csv=toCSV(entries);

    if (window.showSaveFilePicker){
      try{
        const handle = await window.showSaveFilePicker({
          suggestedName: "wolf-recovery-data.csv",
          types: [{ description: "CSV", accept: {"text/csv":[".csv"]} }]
        });
        const writable = await handle.createWritable();
        await writable.write(csv);
        await writable.close();
        alert("Exported CSV backup.");
        return;
      }catch(err){
        // user cancelled -> fall back silently
      }
    }

    const blob=new Blob([csv], {type:"text/csv;charset=utf-8"});
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download="wolf-recovery-data.csv";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function getThresholds(mode){
    if (mode==="adt"){
      return { zOutlier:1.6, rhrAbs:6, hrvDropPct:0.18, recDropAbs:10, fatigueHigh:6, fatigueLow:4, jointWarn:4,
        disagreementPenalty:25, outlierPenalty:25, fatigueMismatchPenalty:25, trainingPenalty:10, stepsSwingPenalty:10 };
    }
    return { zOutlier:2.0, rhrAbs:8, hrvDropPct:0.22, recDropAbs:12, fatigueHigh:7, fatigueLow:4, jointWarn:5,
      disagreementPenalty:20, outlierPenalty:20, fatigueMismatchPenalty:20, trainingPenalty:8, stepsSwingPenalty:8 };
  }

  function computeBaselines(entries, baselineDays, todayDate){
    const sorted=[...entries].sort(byDateAsc);
    const idx=sorted.findIndex(e=>e.date===todayDate);
    const prior=(idx===-1?sorted:sorted.slice(0,idx));
    const window=prior.slice(Math.max(0, prior.length-baselineDays));
    const fields=["mReady","mHrv","ouraRec","whoopRec","whoopRhr","ouraRhr","steps","fatigue","joint"];
    const base={};
    for (const f of fields){
      const xs=window.map(e=>e[f]);
      base[f]={ mean:mean(xs), sd:sd(xs), n:xs.filter(x=>x!=null).length };
    }
    return base;
  }

  function classifyRecovery(entry){
    const votes=[];
    if (entry.mReady!=null) votes.push({device:"Morpheus", signal:"mReady", score: entry.mReady});
    if (entry.ouraRec!=null) votes.push({device:"Oura", signal:"ouraRec", score: entry.ouraRec});
    if (entry.whoopRec!=null) votes.push({device:"Whoop", signal:"whoopRec", score: entry.whoopRec});
    else if (entry.whoopRhr!=null) votes.push({device:"Whoop", signal:"whoopRhrProxy", score: 120-entry.whoopRhr});
    return votes;
  }

  function outlierFlags(entry, base, t){
    const flags=[];
    const zflag=(field, hint)=>{
      const b=base[field];
      if (!b || b.mean==null || entry[field]==null) return;
      if (!b.sd || b.sd===0) return;
      const z=(entry[field]-b.mean)/b.sd;
      if (Math.abs(z) >= t.zOutlier) flags.push({field, kind:"z", z, hint});
    };

    zflag("mReady","Readiness");
    zflag("mHrv","HRV");
    zflag("ouraRec","Recovery");
    zflag("whoopRec","Recovery");
    zflag("whoopRhr","RHR");
    zflag("ouraRhr","RHR");
    // Steps are optional; do not treat missing/0-today as a physiological outlier
    if (!(entry.date === TODAY && entry.steps === 0)) zflag("steps","Steps");
    zflag("fatigue","Fatigue");

    if (base.whoopRhr?.mean!=null && entry.whoopRhr!=null && (entry.whoopRhr-base.whoopRhr.mean)>=t.rhrAbs)
      flags.push({field:"whoopRhr", kind:"abs", hint:`Whoop RHR +${t.rhrAbs} bpm vs baseline`});
    if (base.ouraRhr?.mean!=null && entry.ouraRhr!=null && (entry.ouraRhr-base.ouraRhr.mean)>=t.rhrAbs)
      flags.push({field:"ouraRhr", kind:"abs", hint:`Oura RHR +${t.rhrAbs} bpm vs baseline`});
    if (base.mHrv?.mean!=null && entry.mHrv!=null){
      const drop=(base.mHrv.mean-entry.mHrv)/base.mHrv.mean;
      if (drop>=t.hrvDropPct) flags.push({field:"mHrv", kind:"pct", hint:`HRV drop ≥${Math.round(t.hrvDropPct*100)}% vs baseline`});
    }
    if (base.mReady?.mean!=null && entry.mReady!=null && (base.mReady.mean-entry.mReady)>=t.recDropAbs)
      flags.push({field:"mReady", kind:"abs", hint:`Readiness drop ≥${t.recDropAbs}`});
    if (base.ouraRec?.mean!=null && entry.ouraRec!=null && (base.ouraRec.mean-entry.ouraRec)>=t.recDropAbs)
      flags.push({field:"ouraRec", kind:"abs", hint:`Recovery drop ≥${t.recDropAbs}`});
    if (base.whoopRec?.mean!=null && entry.whoopRec!=null && (base.whoopRec.mean-entry.whoopRec)>=t.recDropAbs)
      flags.push({field:"whoopRec", kind:"abs", hint:`Recovery drop ≥${t.recDropAbs}`});
    return flags;
  }

  function computeDayAssessment(entry, entries, baselineDays, mode, _depth=0){
    const t=getThresholds(mode);
    const base=computeBaselines(entries, baselineDays, entry.date);
    const flags=outlierFlags(entry, base, t);

    // Morning workflow support: if steps are 0 on today's date, treat as missing (not a true zero-step day).
    

    const stepsMissing = !!entry.morningEntry || (entry.steps == null);


    
    // ----------------------------
    // Load sequencing (anti-stacking) — ADT/CFS-friendly
    // If the TWO prior calendar days were both high-step days (>= 9500),
    // recommend a Scout day today (move, but de-stack load).
    // ----------------------------
    const HIGH_STEPS_STABLE = 9500;
    const HIGH_STEPS_EXPERIMENTAL = 9000; // more sensitive
    const HIGH_STEPS = () => (isExperimental() ? HIGH_STEPS_EXPERIMENTAL : HIGH_STEPS_STABLE);

    function _daysDiff(aISO, bISO){
      const a = new Date(aISO + "T00:00:00");
      const b = new Date(bISO + "T00:00:00");
      return Math.round((b - a) / (24*60*60*1000));
    }

    let loadStackFlag = false;
    try{
      const sortedSeq = [...entries].sort(byDateAsc);
      const i = sortedSeq.findIndex(e => e.date === entry.date);
      if (i >= 2){
        const d1 = sortedSeq[i-1];
        const d2 = sortedSeq[i-2];

        const consecutive =
          (_daysDiff(d2.date, d1.date) === 1) &&
          (_daysDiff(d1.date, entry.date) === 1);

        const s1 = (d1.steps == null ? null : Number(d1.steps));
        const s2 = (d2.steps == null ? null : Number(d2.steps));

        if (consecutive && s1 != null && s2 != null && s1 >= HIGH_STEPS() && s2 >= HIGH_STEPS()){
          loadStackFlag = true;
        }
      }
    } catch(e){}
const votes=classifyRecovery(entry);
    const voteResults=[];
    for (const v of votes){
      let bmean=null;
      if (v.signal==="mReady") bmean=base.mReady?.mean;
      if (v.signal==="ouraRec") bmean=base.ouraRec?.mean;
      if (v.signal==="whoopRec") bmean=base.whoopRec?.mean;
      if (v.signal==="whoopRhrProxy") bmean=(base.whoopRhr?.mean!=null ? 120-base.whoopRhr.mean : null);

      let state="neutral";
      if (bmean!=null && v.score!=null){
        const delta=v.score-bmean;
        if (delta>=2) state="ok";
        else if (delta<=-2) state="stressed";
      } else if (v.score!=null){
        if (v.score>=70) state="ok";
        else if (v.score<=45) state="stressed";
      }
      voteResults.push({device:v.device, state});
    }

    const okCount=voteResults.filter(x=>x.state==="ok").length;
    const stCount=voteResults.filter(x=>x.state==="stressed").length;
    let majority="mixed";
    if (okCount>=2) majority="ok";
    if (stCount>=2) majority="stressed";

    let fatigueSignal="unknown";
    if (entry.fatigue!=null){
      if (entry.fatigue>=t.fatigueHigh) fatigueSignal="stressed";
      else if (entry.fatigue<=t.fatigueLow) fatigueSignal="ok";
      else fatigueSignal="neutral";
    }

    let disagreement = (majority==="mixed") ? true : (voteResults.some(v=>v.state!=="neutral" && v.state!==majority));
    // ADT/CFS nuance: Morpheus is a wake-test snapshot. If Oura + Whoop agree (OK) and only Morpheus is "stressed",
    // treat it as an AM autonomic dip rather than a true cross-device disagreement.
    const vM = voteResults.find(v=>v.device==="Morpheus");
    const vO = voteResults.find(v=>v.device==="Oura");
    const vW = voteResults.find(v=>v.device==="Whoop");
    if (majority==="ok" && vM && vO && vW && vM.state==="stressed" && vO.state==="ok" && vW.state==="ok") {
      disagreement = false;
      if (whyBullets) whyBullets.push("Morpheus wake-test is low while Oura/Whoop look OK → treat as an AM autonomic dip (snapshot), not an overnight sleep signal.");
    }
    const fatigueMismatch = (fatigueSignal!=="unknown" && fatigueSignal!=="neutral" && majority!=="mixed" && fatigueSignal!==majority);

    let conf=100;
    const outlierFieldsSet=new Set(flags.map(f=>f.field));
    const outlierCount=outlierFieldsSet.size;

    // Penalize outliers, but treat "positive-direction" outliers as less alarming
    // (e.g., higher recovery, lower RHR, lower fatigue can reduce uncertainty rather than increase it).
    let outlierPenaltyTotal = 0;
    const seenOut = new Set();
    for (const f of flags){
      if (seenOut.has(f.field)) continue;
      seenOut.add(f.field);
      let p = t.outlierPenalty;

      if (f.kind==="z"){
        const z = Number(f.z);
        const positiveDirection =
          ((f.field==="ouraRec" || f.field==="whoopRec" || f.field==="mReady" || f.field==="mHrv") && z>0) ||
          ((f.field==="ouraRhr" || f.field==="whoopRhr") && z<0) ||
          (f.field==="fatigue" && z<0);

        if (positiveDirection){
          p = Math.round(t.outlierPenalty * 0.35); // smaller penalty for "good news" outliers
        }
      }
      outlierPenaltyTotal += p;
    }

    conf -= outlierPenaltyTotal;
    if (disagreement) conf -= t.disagreementPenalty;
    if (fatigueMismatch) conf -= t.fatigueMismatchPenalty;
    if (entry.resistance==="Y") conf -= t.trainingPenalty;

    if (!stepsMissing && base.steps?.mean!=null && entry.steps!=null && base.steps.mean>0){
      const swing=Math.abs(entry.steps-base.steps.mean)/base.steps.mean;
      if (swing>0.30) conf -= t.stepsSwingPenalty;
    }
    conf=clamp(conf,0,100);

    const outlierFields=new Set(flags.map(f=>f.field));
    const deviceFields={ Morpheus:["mReady","mHrv"], Oura:["ouraRec","ouraRhr"], Whoop:["whoopRec","whoopRhr"] };
    let odd=null, oddWhy="";
    if (majority!=="mixed" && voteResults.length>=2){
      const candidates=voteResults.filter(v=>v.state!=="neutral" && v.state!==majority);
      if (candidates.length===1){
        const c=candidates[0];
        const fields=deviceFields[c.device]||[];
        const hasOutlier=fields.some(f=>outlierFields.has(f));
        const disagreesWithFatigue=(fatigueSignal!=="unknown" && fatigueSignal!=="neutral" && c.state!==fatigueSignal);
        if (hasOutlier && (fatigueSignal==="unknown" || disagreesWithFatigue)){
          odd=c.device;
          oddWhy=`Conflicts with majority (${majority}) and shows outlier behavior in ${fields.filter(f=>outlierFields.has(f)).join(", ") || "device metrics"}.`;
        }
      }
    }

    let rec="Green";
    const why=[];
    if (conf<55) rec="Red";
    else if (conf<80) rec="Blue";

    if (entry.joint!=null && entry.joint>=t.jointWarn){
      if (rec==="Green") rec="Blue";
      why.push(`Joint warning ${entry.joint}/10 → joint-protective bias.`);
    }
    if (fatigueSignal==="stressed"){
      if (rec==="Green") rec="Blue";
      if (conf<55) rec="Red";
      why.push(`Fatigue ${entry.fatigue}/10 indicates strain.`);
    }
    if (outlierCount) why.push(`${outlierCount} outlier signal(s) vs baseline.`);
    if (disagreement) why.push(`Devices disagree → uncertainty day.`);
    if (!why.length) why.push("Stable vs baseline; devices mostly consistent.");
    // --- Integration Lag / Delayed Absorption detection (ADT/CFS-friendly) ---
// Goal: avoid labeling a "true crash" when fatigue is not high and recent load was significant.
// Primary Dysregulation should be reserved for days that *feel* like a crash (high fatigue / flu-like / fuses blown),
// not for days where the system is simply integrating prior load with a 24–48h lag.
let cycleLabel = "";
let diurnalRebound = false;
if (_depth===0){
  try{
    const sorted = entries.slice().sort(byDateAsc);
    const idx = sorted.findIndex(e=>e.date===entry.date);

    // Lookback window for load memory (last 4 completed days)
    const lookback = [];
    for (let k=1; k<=4; k++){
      if (idx-k >= 0) lookback.push(sorted[idx-k]);
    }

    const stepsVals = lookback
      .map(e => (e.steps==null ? null : Number(e.steps)))
      .filter(v => v!=null && !isNaN(v) && v>0);

    const highDays = stepsVals.filter(v => v >= HIGH_STEPS()).length;
    const sumSteps = stepsVals.reduce((a,b)=>a+b,0);

    const recentLoad = (highDays >= 2) || (highDays >= 1 && sumSteps >= 20000);

    // A "crash-feel" proxy: very high fatigue or strong crash language in notes
    const notesTxt = String(entry.notes||"").toLowerCase();
    const crashWords = /(flu|fuses|blown|dizzy|ill|crash|can'?t move|barely|heavy|down)/;
    const crashFeel = (entry.fatigue!=null && entry.fatigue >= t.fatigueHigh) || crashWords.test(notesTxt);

    // "Improving / lifting" proxy: cues that the day is not a true crash
    const liftWords = /(better|less pain|lifting|lifted|improving|ok|fine|felt good|energetic)/;
    const improving = liftWords.test(notesTxt) || (entry.fatigue!=null && entry.fatigue <= (t.fatigueHigh-2));

    // Diurnal rebound proxy (ADT/CFS pattern): rough morning but clearly "comes online" later.
    // Uses only Notes + Fatigue because the app is designed for morning entry (steps may be blank).
    const reboundWords = /(lifted|lifting|comes online|by 1pm|by 2pm|by 3pm|afternoon|evening|later.*better|energy.*good|regulated later|rebound)/;
    diurnalRebound = reboundWords.test(notesTxt) && (entry.fatigue==null || entry.fatigue <= t.fatigueHigh-1);


    // If the devices say stressed but fatigue isn't high and recent load exists, treat as Integration Lag.
    if (mode==="adt" && majority==="stressed" && fatigueSignal!=="stressed" && recentLoad && improving){
      cycleLabel = "Integration lag (Delayed absorption)";
    }

    // If we are stressed and clearly crash-feel, keep it as Primary Dysregulation (no cycleLabel).
    // (cycleLabel remains empty)
  } catch(e){}
}
// Recommendation display text (separate from color)

    // In ADT/CFS context: movement is the default; we modulate intensity + intent.
    let recColor = rec; // Green/Yellow/Red
    let recText = rec;

    // Explanatory notes
    if (cycleLabel){
      why.push("Pattern suggests Integration Lag / Delayed Absorption (common in ADT/CFS physiology): protect the morning and reassess later in the day.");
    }
    if (stepsMissing){
      why.push("Steps not yet entered (morning entry) → steps excluded from outliers/confidence.");
    }

    // Movement guidance phrases
    const moveRoam = "Roam (easy hills OK)";
    const moveConsolidate = "Consolidate (easy / repeatable)";
    const moveScout = "Scout (de-stack load)";
    const movePrime = "Prime (gentle reset)";

    // --- Strategy (what to do) ---
    // We keep phases (REGULATED / TRANSITIONAL / INTEGRATION LAG / PROTECTIVE RESET)
    // separate from strategy (Scout / Consolidate / Expand), to reduce fear + improve decisions.
    let strategy = "Consolidate";
    let strategyLine = "";
    let plan = "";

    // Helper: choose strategy based on readiness + load memory + sequencing + joints
    const joint = num(entry.joint);
    const fat = num(entry.fatigue);
    const load = (typeof loadMem === "number" ? loadMem : 0);
    const phaseLabel = voteLabelFromAssess({majority, fatigueSignal, cycleLabel});

    const lowJoint = (isNaN(joint) || joint <= 4);
    const lowFat = (isNaN(fat) || fat <= 4);

    // Default strategy by phase
    if (phaseLabel.startsWith("PROTECTIVE RESET")){
      strategy = "Prime";
      strategyLine = `Prime, Don't Train — ${movePrime}`;
      plan = "Gentle reset first. If the heaviness starts to lift, take a short, easy walk (minutes, not miles). Skip intensity and strength today unless it clearly improves symptoms. Reassess after ~3–5 pm.";
    } else if (phaseLabel.startsWith("INTEGRATION LAG")){
      strategy = "Scout";
      strategyLine = `Scout Day — ${moveScout}`;
      plan = "Stay in motion to maintain trust, but de-stack load. Keep it easy and boring: shorter or flatter route, conversational pace, no testing. End feeling you could do more. Reassess after ~3–5 pm.";
    } else if (phaseLabel==="TRANSITIONAL"){
      strategy = "Consolidate";
      strategyLine = `Consolidate & Observe — ${moveConsolidate}`;
      plan = "Keep the walk easy/conversational; prefer flatter routes; avoid 'testing' the system. Let the afternoon confirm stability before adding anything.";
    } else { // REGULATED
      // Regulated can still be in consolidation depending on recent load.
      if (load >= 0.35 || !lowJoint){
        strategy = "Consolidate";
        strategyLine = `Build Durability — ${moveConsolidate}`;
        plan = "System looks harmonized. Keep rhythm: normal walk is fine, but keep intent consolidative (no testing). Hills allowed only if they feel smooth. Joint pain = stop early, shorten stride, or choose flatter route.";
      } else {
        strategy = "Expand";
        strategyLine = `Expand Carefully — ${moveRoam}`;
        plan = "System looks harmonized and cleared enough to expand a little. Walk naturally; easy hills OK if it stays smooth. Keep the finish strong (no wobble). Strength work only if joints tolerate and it improves symptoms.";
      }
    }

    // Diurnal rebound override (ADT/CFS pattern):
    // If notes indicate the system comes online later, prefer Scout/Consolidate over Prime.
    if (diurnalRebound && !phaseLabel.startsWith("PROTECTIVE RESET")){
      if (strategy === "Prime") {
        strategy = "Scout";
        strategyLine = `Scout Day — ${moveScout}`;
        plan = "Diurnal rebound noted: keep the morning gentle, but use short, easy movement to help regulation come online. Stop early. Reassess after ~3–5 pm.";
      }
    }

    // Load sequencing override: if two consecutive high-step days were stacked,
    // enforce Scout even if the system looks capable.
    if (mode==="adt" && loadStackFlag){
      why.push(`Load sequencing: two consecutive high-step days (≥${HIGH_STEPS.toLocaleString()} steps) detected → Scout day to prevent delayed dysregulation.`);
      strategy = "Scout";
      strategyLine = `Scout Day — ${moveScout}`;
      // Keep the stricter Scout plan, but if joints are low-risk and loadMem is low, allow a normal-length easy walk.
      plan = "Scout day: move to maintain trust, but de-stack load. Keep pace conversational; avoid pushing hills. Normal length is okay if it stays smooth; end feeling you could do more. Skip strength unless it clearly improves symptoms and joints feel safe.";
    }

    // Map strategy to the app's color families (no amber)
    let recColor = (strategy==="Expand") ? "Green" : (strategy==="Prime" ? "Purple" : "Blue");
    let recText = strategyLine;

    // Add a short cycle-map hint into Why (helps interpretation without extra clicks)
    const cycleMapHint = "Cycle map: Scout → Consolidate → Expand. Prime is a short reset when load temporarily exceeds integration."; 
    if (!why.includes(cycleMapHint)) why.push(cycleMapHint);

    // Signal Tension: capacity vs consolidation mismatch (no single faulty device)
 capacity vs consolidation mismatch (no single faulty device)
    const highReady = flags.some(f => f.field==="mReady" && f.kind==="z" && f.z >= t.zOutlier);
    const lowOuraRec = flags.some(f => f.field==="ouraRec" && ((f.kind==="z" && f.z <= -t.zOutlier) || f.kind==="abs"));
    const tension = (!!highReady && !!lowOuraRec && !odd);
    const tensionLabel = tension ? "Capacity vs consolidation mismatch" : "";
    const tensionWhy = tension ? "Morpheus capacity unusually high while Oura recovery consolidation dropped; treat as timing/prime issue, not a faulty device." : "";
    if (tension) why.push("Signal Tension: capacity vs consolidation mismatch (no faulty device).");

    
    // --- Primary limiter (optional override) ---
    const overrideLimiter = (entry.limiter || "AUTO").toUpperCase();
    let primaryLimiterCode = "AUTO";
    let limiterWhy = "Auto-detected from symptoms, joints, and device signals.";
    if (overrideLimiter !== "AUTO") {
      primaryLimiterCode = overrideLimiter;
      limiterWhy = "Override set in the form (you can switch back to Auto anytime).";
    } else {
      const joint = num(entry.joint);
      const fat = num(entry.fatigue);
      const note = (entry.notes || "");
      const mechScore =
        (joint >= 6 ? 3 : joint >= 5 ? 2 : joint >= 4 ? 1 : 0) +
        (/knee|hip|sciatic|sacrum|joint|tendon|pain/i.test(note) ? 1 : 0);
      const metaScore =
        (fat >= 7 ? 3 : fat >= 6 ? 2 : fat >= 5 ? 1 : 0) +
        (fatigueSignal === "STRESSED" ? 1 : 0) +
        (cycleLabel.includes("DYSREGULATION") ? 2 : 0) +
        (cycleLabel.includes("INTEGRATION LAG") ? 1 : 0);

      if (mechScore >= 3 && metaScore >= 3) {
        primaryLimiterCode = "MIXED";
        limiterWhy = "Both joints and neuro-energy are signaling limits today.";
      } else if (mechScore > metaScore && mechScore >= 3) {
        primaryLimiterCode = "MECHANICAL";
        limiterWhy = "Joint/tendon signals are the tightest limiter today.";
      } else if (metaScore > mechScore && metaScore >= 3) {
        primaryLimiterCode = "METABOLIC";
        limiterWhy = "Neuro-energy / metabolic signals are the tightest limiter today.";
      } else if (mechScore >= 2 && metaScore >= 2) {
        primaryLimiterCode = "MIXED";
        limiterWhy = "Signals are mixed; treat it as a dual-limiter day.";
      } else if (mechScore >= 2) {
        primaryLimiterCode = "MECHANICAL";
        limiterWhy = "Mild joint bias today.";
      } else if (metaScore >= 2) {
        primaryLimiterCode = "METABOLIC";
        limiterWhy = "Mild neuro-energy bias today.";
      } else {
        primaryLimiterCode = "AUTO";
        limiterWhy = "No clear limiter dominates; follow the integration phase guidance.";
      }
    }

    const primaryLimiter =
      primaryLimiterCode === "MECHANICAL" ? "Mechanical (joints/tendons)" :
      primaryLimiterCode === "METABOLIC"  ? "Metabolic (neuro-energy)" :
      primaryLimiterCode === "MIXED"      ? "Mixed (both limiters)" :
      "Auto / none dominant";

    // Modulate the plan to match the limiter (without turning it into a centipede).
    if (primaryLimiterCode === "MECHANICAL") {
      plan = "- Joint-conserving bias: flatter route, shorter duration; avoid bending-forward && deep ROM; stop if pain rises.\n" + plan;
    } else if (primaryLimiterCode === "METABOLIC") {
      plan = "- Neuro-energy bias: keep it very easy; stop early if heaviness increases; avoid “testing” intensity.\n" + plan;
    } else if (primaryLimiterCode === "MIXED") {
      plan = "- Mixed limiter: easy pace *and* joint-conserving route; keep it boring && repeatable.\n" + plan;
    }
return { flags, voteResults, majority, fatigueSignal, disagreement, fatigueMismatch, conf,
      primaryLimiter, limiterWhy,
      oddOneOut:odd, oddWhy, signalTension:tensionLabel, tensionWhy, recColor, recText, cycleLabel, why:why.join(" "), plan };

  }

  const els = {
    date: document.getElementById("date"),
    mReady: document.getElementById("mReady"),
    mHrv: document.getElementById("mHrv"),
    ouraRec: document.getElementById("ouraRec"),
    whoopRec: document.getElementById("whoopRec"),
    whoopRhr: document.getElementById("whoopRhr"),
    ouraRhr: document.getElementById("ouraRhr"),
    steps: document.getElementById("steps"),
    morningEntry: document.getElementById("morningEntry"),
    fatigue: document.getElementById("fatigue"),
    amState: document.getElementById("amState"),
    pmShift: document.getElementById("pmShift"),
    liftTime: document.getElementById("liftTime"),
    resistance: document.getElementById("resistance"),
    joint: document.getElementById("joint"),
    limiter: document.getElementById("limiter"),
    notes: document.getElementById("notes"),
    baseDays: document.getElementById("baseDays"),
    mode: document.getElementById("mode"),
    importFileInput: document.getElementById("importFileInput")
  };

// Morning-entry UI logic
els.morningEntry.addEventListener('change', () => {
  els.morningEntry.dataset.userToggled = '1';
  syncMorningEntryUI();
});
els.date.addEventListener('change', syncMorningEntryUI);
// Initialize defaults
if (!els.date.value) els.date.value = TODAY;
syncMorningEntryUI();


  function getFormEntry(){
    const date = els.date.value;
    if (!date) return null;

    // Steps are an *outcome* of the day. In the morning, leave blank.
    // If a user enters 0 on the same day (common when entering morning state), treat it as missing.
    

    const stepsRaw = parseNum(els.steps.value);
    const morningEntry = (els.morningEntry.checked && date === TODAY);
    // If morning entry, steps are pending and excluded until filled later
    const steps = morningEntry ? null : stepsRaw;

    return {
      date,
      mReady: parseNum(els.mReady.value),
      mHrv: parseNum(els.mHrv.value),
      ouraRec: parseNum(els.ouraRec.value),
      whoopRec: parseNum(els.whoopRec.value),
      whoopRhr: parseNum(els.whoopRhr.value),
      ouraRhr: parseNum(els.ouraRhr.value),
      steps,
      morningEntry,
      fatigue: parseNum(els.fatigue.value),
      resistance: els.resistance.value || "N",
      joint: parseNum(els.joint.value),
      limiter: (els.limiter?.value || "AUTO"),
      notes: (els.notes.value || "").trim(),
      amState: (els.amState?.value || ""),
      pmShift: (els.pmShift?.value || ""),
      liftTime: (els.liftTime?.value || "")
    };
  }

  function setFormEntry(e){
    els.date.value = e.date || "";
    els.mReady.value = e.mReady ?? "";
    els.mHrv.value = e.mHrv ?? "";
    els.ouraRec.value = e.ouraRec ?? "";
    els.whoopRec.value = e.whoopRec ?? "";
    els.whoopRhr.value = e.whoopRhr ?? "";
    els.ouraRhr.value = e.ouraRhr ?? "";
    els.steps.value = e.steps ?? "";
      // Restore morning-entry flag only when date is today
      els.morningEntry.checked = !!e.morningEntry && (e.date === TODAY);
      els.morningEntry.dataset.userToggled = "1";
      syncMorningEntryUI();
    els.fatigue.value = e.fatigue ?? "";
    els.resistance.value = e.resistance || "N";
    els.joint.value = e.joint ?? "";
    if (els.limiter) els.limiter.value = e.limiter ?? "AUTO";
    els.notes.value = e.notes || "";
    if (els.amState) els.amState.value = e.amState || "";
    if (els.pmShift) els.pmShift.value = e.pmShift || "";
    if (els.liftTime) els.liftTime.value = e.liftTime || "";
  }

  function clearForm(){
    setFormEntry({ date: TODAY, resistance:"N" });
  }

  function upsertEntry(newEntry){
    const entries = loadEntries();
    const i = entries.findIndex(e => e.date === newEntry.date);
    if (i >= 0) entries[i] = newEntry; else entries.push(newEntry);
    saveEntries(entries.sort(byDateAsc));
  }

  async function copyText(text){
    try { await navigator.clipboard.writeText(text); alert("Copied."); }
    catch {
      const ta=document.createElement("textarea"); ta.value=text; document.body.appendChild(ta);
      ta.select(); document.execCommand("copy"); ta.remove(); alert("Copied.");
    }
  }

  
  function voteLabelFromAssess(a){
  // a.majority: "ok" | "mixed" | "stressed"
  // a.fatigueSignal: "OK" | "NEUTRAL" | "STRESSED"
  // a.cycleLabel: optional extra labeling (e.g., Integration lag / delayed absorption)
  // Goal: non-alarmist ADT/CFS framing — phases of regulation + integration, not doom states.
  const maj = (a.majority||"").toLowerCase();
  const cyc = String(a.cycleLabel||"").toLowerCase();
  const fat = String(a.fatigueSignal||"").toUpperCase();

  if (maj==="ok"){
    return "REGULATED";
  }
  if (maj==="mixed"){
    // Mixed signals are often a transition or a diurnal / sequencing effect.
    return "TRANSITIONAL";
  }
  // maj === "stressed"
  if (cyc.includes("integration lag") || cyc.includes("delayed")){
    return "INTEGRATION LAG — Delayed Absorption";
  }
  // If both devices and fatigue flag stress, treat as a protective reset (temporary disruption).
  if (fat==="STRESSED"){
    return "PROTECTIVE RESET — Load Exceeded (Temporary)";
  }
  // Otherwise treat as integration lag by default in ADT/CFS context.
  return "INTEGRATION LAG — Delayed Absorption";
}

function loadMemStatusFromValue(v){
  // Relative units; tuned for "directionally correct" PEM visibility.
  if (v < 2.0) return {status:"CLEARING", desc:
function percentile(arr,p){
  const a=arr.filter(x=>Number.isFinite(x)).slice().sort((x,y)=>x-y);
  if(!a.length) return NaN;
  const idx=(a.length-1)*p;
  const lo=Math.floor(idx), hi=Math.ceil(idx);
  if(lo===hi) return a[lo];
  const w=idx-lo;
  return a[lo]*(1-w)+a[hi]*w;
}
function estimateCognitiveLoad(note){
  const s=(note||"").toLowerCase();
  // simple, intentionally coarse: just enough to catch "desk marathon" days
  const hits = [
    /(desk|computer|laptop|email|zoom|calls?|meetings?)/,
    /(long hours|all day|marathon|intense|deadline|grant|budget|invoice)/,
    /(stress|anxious|overwhelmed|burnt|fried|brain fog)/,
  ].reduce((acc,rx)=>acc+(rx.test(s)?1:0),0);
  if(hits===0) return 0;
  if(hits===1) return 0.15;
  if(hits===2) return 0.30;
  return 0.45;
}
function computeLoadMemorySeries(entries, viewDate){
  const rows = (entries||[]).slice().sort((a,b)=>parseDate(a.date)-parseDate(b.date));
  const stepsArr = rows.map(r=>num(r.steps)).filter(n=>Number.isFinite(n) && n>0);
  const p75 = percentile(stepsArr,0.75);
  const HIGH_STEPS = Math.max(9500, Number.isFinite(p75)?p75:9500);

  // Calibrate scale to *your* dataset shape (Jan–Feb): keep LoadMem in a readable 0–1.2 band.
  const stepMedian = percentile(stepsArr,0.50) || 6000;
  const stepScale = (stepMedian>0)? (1.0/stepMedian) : (1.0/6000);

  const baseClear = 0.22;         // baseline daily clearance
  const extraClear = 0.08;        // faster clearance when LoadMem is low (system freer to clear)
  let mem = 0;
  const series = [];
  const loads = [];

  rows.forEach(r=>{
    const isViewDay = (viewDate && r.date===viewDate);
    const stepsMissing = (r.steps===null || r.steps===undefined || r.steps==="" || r.steps===0) && isViewDay;
    const steps = stepsMissing ? NaN : num(r.steps);

    const stepLoad = Number.isFinite(steps) ? clamp(steps*stepScale, 0, 1.6) : 0;
    const fatigueLoad = clamp((num(r.fatigue)-4)/3, 0, 1.2);
    const jointLoad = clamp((num(r.jointWarn)-4)/4, 0, 0.9);
    const resLoad = (String(r.resistance||"").toUpperCase()==="Y") ? 0.35 : 0;
    const cogLoad = estimateCognitiveLoad(r.notes);

    // Total daily input load
    const dailyLoad = clamp(stepLoad + fatigueLoad + jointLoad + resLoad + cogLoad, 0, 2.5);

    // Clearance is a bit faster when LoadMem is low; slightly slower when high.
    const clearanceRate = clamp(baseClear + extraClear/(1+mem), 0.18, 0.32);

    mem = clamp(mem*(1-clearanceRate) + dailyLoad*0.42, 0, 1.6);

    series.push(mem);
    loads.push(dailyLoad);

    // attach fields for later use (thresholds & missing flags)
    r.__highSteps = Number.isFinite(steps) && steps>= HIGH_STEPS();
    r.__stepsMissing = stepsMissing;
  });

  return {series, loads, HIGH_STEPS};
}

"Reservoir low — load mostly absorbed."};
  if (v < 4.0) return {status:"INTEGRATING", desc:"Reservoir mid — integration in progress. Avoid stacking."};
  return {status:"SATURATED", desc:"Reservoir high — delayed absorption likely. Scout, don’t stack."};
}

function computeLoadMemory(entries, assessByDate){
  if (!entries || entries.length < 2){
    return {label:"—", status:"—", why:"Add at least 2 days to compute Load Memory.", value:0, series:null};
  }
  const out = computeLoadMemorySeries(entries, assessByDate);
  const memSeries = out.series || [];
  const loads = out.loads || [];
  const value = memSeries.length ? memSeries[memSeries.length-1] : 0;
  const st = loadMemStatusFromValue(value);

  // Capacity approach: stacking load without clearance.
  const rows = (entries||[]).slice().sort((a,b)=>parseDate(a.date)-parseDate(b.date));
  const last = rows[rows.length-1] || {};
  const last2 = rows[rows.length-2] || {};
  const last3 = rows[rows.length-3] || {};

  const rising3 = memSeries.length>=3 && (memSeries[memSeries.length-1] > memSeries[memSeries.length-2]) && (memSeries[memSeries.length-2] > memSeries[memSeries.length-3]);
  const highCount4 = rows.slice(-4).filter(r=>r.__highSteps).length;
  const approaching = (highCount4>=3) || (rising3 && value>0.75) || (rows.slice(-2).every(r=>r.__highSteps) && value>0.60);

  // Clearance badge: show if we’re coming down from a recent peak.
  const lookback = Math.min(10, memSeries.length);
  const window = memSeries.slice(-lookback);
  const peak = Math.max(...window);
  const peakIdx = window.indexOf(peak); // within window
  const cur = window[window.length-1];
  const prev = window.length>=2 ? window[window.length-2] : cur;
  const clearingNow = (peakIdx < window.length-1) && (cur <= prev + 1e-6); // not rising
  const daysSincePeak = clearingNow ? (window.length-1 - peakIdx) : 0;
  const clearedPct = (clearingNow && peak>0) ? clamp((peak-cur)/peak, 0, 1) : 0;

  let why = st.why;
  if (approaching){
    why = `Load approaching current capacity (${out.HIGH_STEPS.toFixed(0)}+ step stacking / rising LoadMem). Today is best treated as a de-stack day.`;
  } else if (clearingNow && daysSincePeak>=1){
    why = `Clearance in progress: Day ${daysSincePeak} after recent peak. Keep movement easy while the system absorbs and clears.`;
  }

  const label = st.label;
  const status = st.status;

  return {
    label,
    status,
    why,
    value,
    series: memSeries,
    highStepsThreshold: out.HIGH_STEPS,
    approachingCapacity: approaching,
    clearanceDays: daysSincePeak,
    clearancePct: clearedPct
  };
}


function drawLoadChart(seriesObj){
  const canvas = document.getElementById("loadChart");
  if (!canvas || !seriesObj || !seriesObj.series) return;
  const ctx = canvas.getContext("2d");
  const {mem, tail} = seriesObj.series;

  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background grid
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;

  const pad = 10;
  const w = canvas.width, h = canvas.height;
  const innerW = w - pad*2, innerH = h - pad*2;

  // compute y scale
  const maxV = Math.max(1, ...mem);
  const minV = 0;

  function x(i){ return pad + (mem.length===1 ? 0 : (i/(mem.length-1))*innerW); }
  function y(v){ return pad + innerH - ((v-minV)/(maxV-minV))*innerH; }

  // subtle baseline line
  ctx.strokeStyle = "#e6e8ee";
  for (let k=0;k<=3;k++){
    const yy = pad + (k/3)*innerH;
    ctx.beginPath(); ctx.moveTo(pad, yy); ctx.lineTo(pad+innerW, yy); ctx.stroke();
  }

  // line
  ctx.strokeStyle = "#111";
  ctx.lineWidth = 2;
  ctx.beginPath();
  mem.forEach((v,i)=>{
    const xx=x(i), yy=y(v);
    if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  });
  ctx.stroke();

  // fill under curve
  ctx.globalAlpha = 0.08;
  ctx.fillStyle = "#111";
  ctx.lineTo(pad+innerW, pad+innerH);
  ctx.lineTo(pad, pad+innerH);
  ctx.closePath();
  ctx.fill();
  ctx.globalAlpha = 1;

  // last point marker
  const lastX = x(mem.length-1), lastY = y(mem[mem.length-1]);
  ctx.fillStyle = "#111";
  ctx.beginPath(); ctx.arc(lastX,lastY,3,0,Math.PI*2); ctx.fill();
}




  function render(){
    const entries = loadEntries().sort(byDateAsc);
    document.getElementById("entryCount").textContent = String(entries.length);
    document.getElementById("baselineLabel").textContent = `${els.baseDays.value}d`;
    document.getElementById("modeLabel").textContent = els.mode.value === "adt" ? "ADT" : "Standard";

    const latest = entries.length ? entries[entries.length-1] : null;
    if (latest){
      const assess = computeDayAssessment(latest, entries, Number(els.baseDays.value), els.mode.value);
      document.getElementById("todayRec").textContent = assess.recText;
      const vtxt = voteLabelFromAssess(assess);
      const vEl = document.getElementById("todayVote");
      if (vEl){
        const phaseClass = assess.cycleLabel ? "phase-lag"
          : (assess.majority==="ok") ? "phase-regulated"
          : (assess.majority==="mixed") ? "phase-transitional"
          : (assess.majority==="stressed") ? "phase-reset"
          : "";
        vEl.innerHTML = vtxt ? `<span class="phasePill ${phaseClass}">${escapeHTML(vtxt)}</span>` : "—";
      }
      const fEl = document.getElementById("fatigueSig");
      const fdEl = document.getElementById("fatigueDetail");
      const fwEl = document.getElementById("fatigueWhy");
      if (fEl){
        const sig = (assess.fatigueSignal||"neutral");
        const label = sig==="ok" ? "Online / Capable" : sig==="stressed" ? "Flat / Heavy (Neuro‑energy low)" : "Mixed / Variable";
        fEl.textContent = label;
      }
      if (fdEl){
        const f = (latest.fatigue==null ? "—" : String(latest.fatigue));
        fdEl.textContent = `Fatigue rating: ${f}/10`;
      }
      if (fwEl){
        const sig = (assess.fatigueSignal||"neutral");
        fwEl.textContent = sig==="ok" ? "Neuro‑energy is available. Still respect load memory + joints." : sig==="stressed" ? "Neuro‑energy hasn’t come online yet. Morning protection + reassess later." : "Mixed signal. Scout early; if you lift by 3–5pm, resume a normal easy walk.";
      }
      setTodayWhyBullets(`${assess.why} Plan: ${assess.plan}`);
      document.getElementById("todayConf").textContent = String(assess.conf);
      document.getElementById("oddOneOut").textContent = assess.oddOneOut || "—";
      document.getElementById("oddWhy").textContent = assess.oddOneOut ? assess.oddWhy : "No single device is the lone contradiction today.";
      document.getElementById("signalTension").textContent = assess.signalTension || "—";
      document.getElementById("tensionWhy").textContent = assess.tensionWhy || "—";
      const cs = computeCrashSignature(entries, Number(els.baseDays.value));
      document.getElementById("crashSig").textContent = cs.label || "—";
      document.getElementById("crashWhy").textContent = cs.why || "—";

      // Build per-day assessments (for PEM reservoir clearance modeling)
      const assessByDate = {};
      try{
        const mode = String(els.mode.value || "ADT");
        const bd = Number(els.baseDays.value);
        const sortedE = [...entries].sort(byDateAsc);
        for (const e of sortedE){
          assessByDate[e.date] = computeDayAssessment(e, sortedE, bd, mode, 1);
        }
      }catch(e){ /* ignore */ }

      const lm = computeLoadMemory(entries, assessByDate);
      document.getElementById("loadMem").textContent = lm.label || "—";
      document.getElementById("loadMemStatus").textContent = lm.status || "—";
      document.getElementById("loadWhy").textContent = lm.why || "—";
      const capP = document.getElementById("capacityFlagPill");
      const clrP = document.getElementById("clearancePill");
      if (capP){
        if (lm.approachingCapacity){
          capP.textContent = "Load approaching capacity";
          capP.style.display = "inline-flex";
        } else {
          capP.style.display = "none";
        }
      }
      if (clrP){
        if (!lm.approachingCapacity && lm.clearanceDays && lm.clearanceDays>=1){
          const pct = Math.round((lm.clearancePct||0)*100);
          clrP.textContent = `Clearance: Day ${lm.clearanceDays} (${pct}% cleared)`;
          clrP.style.display = "inline-flex";
        } else {
          clrP.style.display = "none";
        }
      }

      drawLoadChart(lm);
const da = computeDiurnalArc(latest);
      const arcEl = document.getElementById("diurnalArc");
      const whyEl = document.getElementById("diurnalWhy");
      if (arcEl) arcEl.textContent = da.arc || "—";
      if (whyEl) whyEl.textContent = da.why || "—";
    } else {
      document.getElementById("todayRec").textContent = "—";
      setTodayWhyBullets("Add an entry to see guidance.");
      const vEl = document.getElementById("todayVote"); if (vEl) vEl.textContent = "—";
      const fEl = document.getElementById("fatigueSig"); if (fEl) fEl.textContent = "—";
      const fdEl = document.getElementById("fatigueDetail"); if (fdEl) fdEl.textContent = "—";
      const fwEl = document.getElementById("fatigueWhy"); if (fwEl) fwEl.textContent = "—";
      document.getElementById("todayConf").textContent = "—";
      document.getElementById("oddOneOut").textContent = "—";
      document.getElementById("oddWhy").textContent = "—";
      document.getElementById("signalTension").textContent = "—";
      document.getElementById("tensionWhy").textContent = "—";
      document.getElementById("crashSig").textContent = "—";
      document.getElementById("crashWhy").textContent = "—";
      document.getElementById("loadMem").textContent = "—";
      document.getElementById("loadWhy").textContent = "—";
    }

    const tbody = document.querySelector("#tbl tbody");
    tbody.innerHTML = "";
    for (const e of entries.slice().reverse()){
      const assess = computeDayAssessment(e, entries, Number(els.baseDays.value), els.mode.value);
      const outlierFields = [...new Set(assess.flags.map(f=>f.field))];
      const voteTxt = voteLabelFromAssess(assess);
      const recClass = assess.recColor==="Green" ? "green" : assess.recColor==="Blue" ? "blue" : assess.recColor==="Purple" ? "purple" : "red";
      const voteClass = voteClassFromAssess(assess);
      const noteTxt = (e.notes||"").slice(0,60);

      const tr=document.createElement("tr");
      tr.innerHTML = `
        <td class="mono">${e.date}</td>
        <td><span class="tag ${voteClass}">${voteTxt}</span></td>
        <td class="mono">${outlierFields.length ? outlierFields.join(", ") : "—"}</td>
        <td class="mono">${assess.conf}</td>
        <td><span class="tag ${recClass}">${assess.recText}</span></td>
        <td class="muted">${noteTxt}${(e.notes||"").length>60?"…":""}</td>
      `;
      tr.style.cursor="pointer";
      tr.addEventListener("click", ()=>setFormEntry(e));
      tbody.appendChild(tr);
    }
  }

  document.getElementById("openFileBtn").addEventListener("click", async ()=>{
    try { await openDataFile(); } catch (e){ alert("Open failed: " + (e?.message || String(e))); }
  });
  document.getElementById("saveFileBtn").addEventListener("click", async ()=>{
    try { await saveDataFile(); } catch (e){ alert("Save failed: " + (e?.message || String(e))); }
  });
  document.getElementById("exportJsonBtn").addEventListener("click", exportJSON);
  document.getElementById("exportCsvBtn").addEventListener("click", exportCSV);

  
  // ----------------------------
  // CSV Import (robust + header aliases) + status
  // ----------------------------
  const importStatusEl = document.getElementById("importStatus");
  function setImportStatus(msg, kind){
    if (!importStatusEl) return;
    importStatusEl.textContent = msg;
    importStatusEl.style.borderColor =
      (kind==="ok") ? "rgba(61,220,151,.35)" :
      (kind==="err") ? "rgba(255,107,107,.35)" :
      "rgba(255,255,255,.14)";
    importStatusEl.style.color =
      (kind==="ok") ? "rgba(61,220,151,.95)" :
      (kind==="err") ? "rgba(255,107,107,.95)" :
      "var(--muted)";
  }

  function parseCSV(text){
    const s = String(text||"").replace(/^\uFEFF/, "");
    const rows = [];
    let row = [];
    let cur = "";
    let inQ = false;

    for (let i=0;i<s.length;i++){
      const ch = s[i];
      const next = s[i+1];

      if (inQ){
        if (ch === '"' && next === '"'){ cur += '"'; i++; }
        else if (ch === '"'){ inQ = false; }
        else { cur += ch; }
      } else {
        if (ch === '"'){ inQ = true; }
        else if (ch === ","){ row.push(cur); cur=""; }
        else if (ch === "\n"){
          row.push(cur);
          row = row.map(x => x.endsWith("\r") ? x.slice(0,-1) : x);
          rows.push(row);
          row = []; cur = "";
        } else { cur += ch; }
      }
    }
    row.push(cur);
    row = row.map(x => x.endsWith("\r") ? x.slice(0,-1) : x);
    if (!(row.length===1 && row[0].trim()==="")) rows.push(row);
    return rows.filter(r => r.some(c => String(c||"").trim() !== ""));
  }

  function normalizeHeader(h){
    return String(h||"")
      .replace(/^\uFEFF/, "")
      .trim()
      .toLowerCase()
      .replace(/\s+/g,"")
      .replace(/[^a-z0-9]/g,"");
  }

  // Accept both canonical headers and your backup headers:
  // Date, MorpheusReady, MorpheusHRV, OuraRecovery, WhoopRecovery, WhoopRHR, OuraRHR, Steps, Fatigue, Resistance, JointWarn, Notes
  const CSV_ALIAS_TO_KEY = {
    "date":"date",
    "morpheusready":"mReady",
    "morpheushrv":"mHrv",
    "mready":"mReady",
    "mhrv":"mHrv",
    "ourarecovery":"ouraRec",
    "ourarec":"ouraRec",
    "whooprecovery":"whoopRec",
    "whooprec":"whoopRec",
    "whooprhr":"whoopRhr",
    "ourarhr":"ouraRhr",
    "steps":"steps",
    "fatigue":"fatigue",
    "resistance":"res",
    "res":"res",
    "jointwarn":"joint",
    "joint":"joint",
    "limiter":"limiter",
    "primarylimiter":"limiter",
    "amstate":"amState",
    "pmshift":"pmShift",
    "lifttime":"liftTime",
    "notes":"notes",
    "note":"notes"
  };

  function coerceYN(v){
    const s = String(v||"").trim().toUpperCase();
    return (s==="Y" || s==="YES" || s==="TRUE" || s==="1") ? "Y" : "N";
  }

  document.getElementById("importCsvBtn")?.addEventListener("click", ()=>{
    document.getElementById("importCsvInput")?.click();
  });

  document.getElementById("importCsvInput")?.addEventListener("change", async (e)=>{
    const file = e.target.files?.[0];
    if (!file){
      setImportStatus("Import status: cancelled.", "neutral");
      return;
    }
    try{
      setImportStatus(`Importing CSV: ${file.name} ...`, "neutral");
      const txt = await file.text();
      const rows2d = parseCSV(txt);
      if (rows2d.length < 2){
        setImportStatus("Import failed: CSV has no data rows.", "err");
        e.target.value = "";
        return;
      }

      const headersRaw = rows2d[0].map(h => String(h||"").trim());
      const headersNorm = headersRaw.map(normalizeHeader);

      const idx = {};
      headersNorm.forEach((hn,i)=>{
        const key = CSV_ALIAS_TO_KEY[hn];
        if (key && idx[key]==null) idx[key]=i;
      });

      if (idx.date == null){
        setImportStatus(`Import failed: missing required column "date".\nFound headers: ${headersRaw.join(", ")}`, "err");
        e.target.value = "";
        return;
      }

      const existing = loadRows();
      const byDate = new Map(existing.map(r => [r.date, r]));

      let added=0, updated=0, skipped=0;

      for (let i=1;i<rows2d.length;i++){
        const line = rows2d[i];
        const date = String(line[idx.date] ?? "").trim();
        if (!date){ skipped++; continue; }

        const row = {
          date,
          mReady: idx.mReady==null ? null : Number(line[idx.mReady]),
          mHrv: idx.mHrv==null ? null : Number(line[idx.mHrv]),
          ouraRec: idx.ouraRec==null ? null : Number(line[idx.ouraRec]),
          whoopRec: idx.whoopRec==null ? null : Number(line[idx.whoopRec]),
          whoopRhr: idx.whoopRhr==null ? null : Number(line[idx.whoopRhr]),
          ouraRhr: idx.ouraRhr==null ? null : Number(line[idx.ouraRhr]),
          steps: idx.steps==null ? null : Number(line[idx.steps]),
          fatigue: idx.fatigue==null ? null : Number(line[idx.fatigue]),
          res: idx.res==null ? "N" : coerceYN(line[idx.res]),
          joint: idx.joint==null ? null : Number(line[idx.joint]),
          amState: idx.amState==null ? "" : String(line[idx.amState] ?? "").trim(),
          pmShift: idx.pmShift==null ? "" : String(line[idx.pmShift] ?? "").trim(),
          liftTime: idx.liftTime==null ? "" : String(line[idx.liftTime] ?? "").trim(),
          notes: idx.notes==null ? "" : String(line[idx.notes] ?? "")
        };

        Object.keys(row).forEach(k=>{
          if (k==="date" || k==="notes" || k==="res" || k==="amState" || k==="pmShift" || k==="liftTime") return;
          if (!Number.isFinite(row[k])) row[k] = null;
        });

        if (byDate.has(date)){ byDate.set(date, row); updated++; }
        else { byDate.set(date, row); added++; }
      }

      const merged = Array.from(byDate.values()).sort((a,b)=>a.date.localeCompare(b.date));
      saveRows(merged);
      render();
      setImportStatus(`CSV import complete ✅\nFile: ${file.name}\nAdded: ${added}\nUpdated: ${updated}\nSkipped (blank date): ${skipped}\nTotal entries now: ${merged.length}`, "ok");
    }catch(err){
      setImportStatus(`Import failed: ${err?.message || String(err)}`, "err");
    }finally{
      e.target.value = "";
    }
  });

  // Initialize status
  setImportStatus("Import status: —", "neutral");

  // --- JSON import (robust: accepts our exports OR a raw array of objects) ---
  const importJsonBtn = document.getElementById("importJsonBtn");
  const importFileInput = document.getElementById("importFileInput");

  importJsonBtn?.addEventListener("click", ()=>{
    if (!importFileInput){
      setImportStatus("Import failed: JSON file input not found in page.", "err");
      return;
    }
    importFileInput.value = "";
    importFileInput.click();
  });

  // Maps any reasonable JSON key → our canonical key
  const JSON_KEYMAP = {
    date: "date",
    morpheusready: "mReady",
    mready: "mReady",
    morpheushrv: "mHRV",
    mhrv: "mHRV",
    ourarecovery: "ouraRec",
    ourarec: "ouraRec",
    whooprecovery: "whoopRec",
    whooprec: "whoopRec",
    whooprhr: "whoopRHR",
    ourarhr: "ouraRHR",
    steps: "steps",
    fatigue: "fatigue",
    resistance: "resistance",
    res: "resistance",
    jointwarn: "jointWarn",
    joint: "jointWarn",
    notes: "notes",
    ourahrv: "ouraHrvStatus",
    ourahrvstatus: "ouraHrvStatus",
    hrvbalance: "ouraHrvStatus"
  };

  function normalizeKey(k){
    return String(k||"").trim().toLowerCase().replace(/[^a-z0-9]+/g, "");
  }

  function mapJsonEntry(obj){
    const row = {
      date: "",
      mReady: null,
      mHRV: null,
      ouraRec: null,
      whoopRec: null,
      whoopRHR: null,
      ouraRHR: null,
      steps: null,
      fatigue: null,
      resistance: "N",
      jointWarn: null,
      ouraHrvStatus: "",
      notes: ""
    };

    for (const [k,v] of Object.entries(obj||{})){
      const nk = normalizeKey(k);
      const key = JSON_KEYMAP[nk];
      if (!key) continue;

      if (key === "date"){
        row.date = String(v||"").slice(0,10);
      } else if (key === "resistance"){
        row.resistance = (String(v||"N").toUpperCase().startsWith("Y")) ? "Y" : "N";
      } else if (key === "notes"){
        row.notes = String(v||"");
      } else if (key === "ouraHrvStatus"){
        row.ouraHrvStatus = String(v||"").trim();
      } else {
        // numeric fields
        row[key] = (v===null || v===undefined || v==="") ? null : num(v);
      }
    }

    // Some exports may use ISO datetime in date
    if (row.date && row.date.includes("T")) row.date = row.date.split("T")[0];
    return row;
  }

  function extractJsonArray(parsed){
    if (Array.isArray(parsed)) return parsed;
    if (!parsed || typeof parsed !== "object") return null;

    // Support common wrappers
    if (Array.isArray(parsed.entries)) return parsed.entries;
    if (Array.isArray(parsed.data)) return parsed.data;
    if (parsed.payload && Array.isArray(parsed.payload.entries)) return parsed.payload.entries;
    if (parsed.payload && Array.isArray(parsed.payload.data)) return parsed.payload.data;
    if (parsed.records && Array.isArray(parsed.records)) return parsed.records;
    return null;
  }

  importFileInput?.addEventListener("change", async (ev)=>{
    const file = ev.target.files?.[0];
    if (!file) return;
    try{
      const text = await file.text();
      const parsed = JSON.parse(text||"null");
      const arr = extractJsonArray(parsed);
      if (!arr) throw new Error("JSON format not recognized. Expected an array, or an object containing entries/data.");

      // Convert to canonical rows
      const imported = [];
      let skipped = 0;
      for (const it of arr){
        const row = mapJsonEntry(it);
        if (!row.date) { skipped++; continue; }
        imported.push(row);
      }

      // Merge by date
      const existing = loadRows();
      const map = new Map(existing.map(r=>[r.date, r]));
      let added = 0, updated = 0;
      for (const r of imported){
        const prev = map.get(r.date);
        if (!prev){ map.set(r.date, r); added++; }
        else { map.set(r.date, { ...prev, ...r }); updated++; }
      }
      const merged = Array.from(map.values()).sort((a,b)=>String(a.date).localeCompare(String(b.date)));
      saveRows(merged);
      render();
      setImportStatus(`JSON import complete ✅\nFile: ${file.name}\nAdded: ${added}\nUpdated: ${updated}\nSkipped (blank date): ${skipped}\nTotal entries now: ${merged.length}`, "ok");
    }catch(err){
      setImportStatus(`Import failed: ${err?.message || String(err)}`, "err");
    }finally{
      ev.target.value = "";
    }
  });

  document.getElementById("addBtn").addEventListener("click", async ()=>{
    const entry=getFormEntry();
    if (!entry){ alert("Pick a date."); return; }
    upsertEntry(entry);
    render();
    if (fileHandle){ try { await saveDataFile(); } catch {} }
  });

  document.getElementById("clearBtn").addEventListener("click", ()=>clearForm());
  document.getElementById("bundleBtn").addEventListener("click", async ()=>{ await copyText(makeAnalysisBundle(loadEntries())); });

  document.getElementById("resetBtn").addEventListener("click", ()=>{
    if (!confirm("Delete all stored data in this browser?")) return;
    localStorage.removeItem(LS_KEY);
    fileHandle=null;
    setDataSourceLabel();
    clearForm();
    render();
  });

  els.baseDays.addEventListener("change", render);
  els.mode.addEventListener("change", render);

  clearForm();
  setDataSourceLabel();
  render();


  // --- Sticky table header offset fix (iOS/Safari friendly) ---
  function setStickyOffsets(){
    const hdr = document.querySelector('header');
    const h = hdr ? Math.round(hdr.getBoundingClientRect().height) : 0;
    document.documentElement.style.setProperty('--headerH', h + 'px');
  }
  window.addEventListener('resize', setStickyOffsets);
  window.addEventListener('orientationchange', () => setTimeout(setStickyOffsets, 50));
  // Run after initial layout and after fonts load
  setStickyOffsets();
  setTimeout(setStickyOffsets, 50);
  setTimeout(setStickyOffsets, 250);


// =========================
// Import/Export Wiring (v26.2)
// =========================
function setImportStatus(msg, isError=false){
  const el = document.getElementById("importStatus");
  if(!el) return;
  el.textContent = msg;
  el.style.color = isError ? "#fecaca" : "#bbf7d0";
}
function readFileAsText(file){
  return new Promise((resolve, reject)=>{
    const r = new FileReader();
    r.onload = ()=> resolve(String(r.result||""));
    r.onerror = ()=> reject(r.error || new Error("File read failed"));
    r.readAsText(file);
  });
}

function coerceBool(v){
  if(v===true||v===false) return v;
  if(v==null) return null;
  const s = String(v).trim().toLowerCase();
  if(["y","yes","true","1"].includes(s)) return true;
  if(["n","no","false","0"].includes(s)) return false;
  return null;
}

// Normalize a date string to YYYY-MM-DD when possible.
function normalizeDate(v){
  if(!v) return "";
  const s = String(v).trim();
  // Already ISO
  if(/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
  // MM/DD/YY or MM/DD/YYYY
  const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
  if(m){
    let mm = m[1].padStart(2,"0");
    let dd = m[2].padStart(2,"0");
    let yy = m[3];
    if(yy.length===2) yy = "20"+yy;
    return `${yy}-${mm}-${dd}`;
  }
  // Try Date.parse
  const d = new Date(s);
  if(!isNaN(d.getTime())){
    const yy = String(d.getFullYear());
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yy}-${mm}-${dd}`;
  }
  return s;
}

function importRowsMerge(incoming){
  const existing = loadRows();
  const byDate = new Map(existing.map(r=>[r.date, r]));
  let importedCount = 0;
  for(const r of incoming){
    if(!r || !r.date) continue;
    byDate.set(r.date, { ...(byDate.get(r.date) || {}), ...r });
    importedCount++;
  }
  const merged = Array.from(byDate.values()).sort((a,b)=> (a.date||"").localeCompare(b.date||""));
  saveRows(merged);
  renderAll();
  setImportStatus(`Imported ${importedCount} row(s). Total now: ${merged.length}.`, false);
}

function importFromCSVText(csvText){
  const rows = parseCSV(csvText);
  if(!rows.length) throw new Error("Empty CSV.");
  const headersRaw = rows[0].map(h=>String(h||"").trim());
  const headersNorm = headersRaw.map(h=>normalizeHeader(h));
  // Build index map using aliases (case-insensitive)
  const idx = {};
  headersNorm.forEach((hn,i)=>{
    const key = CSV_ALIAS_TO_KEY[hn];
    if(key) idx[key]=i;
  });
  if(idx.date==null){
    throw new Error(`Import failed: missing required column "date".\nFound headers: ${headersRaw.join(", ")}`);
  }
  const out = [];
  for(let r=1;r<rows.length;r++){
    const line = rows[r];
    if(!line || !line.length) continue;
    const date = normalizeDate(line[idx.date]);
    if(!date) continue;
    const obj = { date };
    function setNum(key){
      const i = idx[key];
      if(i==null) return;
      const v = num(line[i]);
      if(v!==null) obj[key]=v;
    }
    setNum("mReady"); setNum("mHRV"); setNum("ouraRec"); setNum("whoopRec");
    setNum("whoopRHR"); setNum("ouraRHR"); setNum("steps"); setNum("fatigue");
    // booleans / ints
    if(idx.resistance!=null){
      const b = coerceBool(line[idx.resistance]);
      obj.resistance = b===null ? (String(line[idx.resistance]||"").trim()||null) : b ? "Y":"N";
    }
    if(idx.jointWarn!=null){
      const v = num(line[idx.jointWarn]);
      if(v!==null) obj.jointWarn = v;
    }
    if(idx.notes!=null) obj.notes = String(line[idx.notes]||"").trim();
    out.push(obj);
  }
  importRowsMerge(out);
}

function importFromJSONText(jsonText){
  let parsed;
  try{ parsed = JSON.parse(jsonText); }
  catch(e){ throw new Error("Import failed: invalid JSON."); }
  // Accept either an array of rows, or {rows:[...]}
  const arr = Array.isArray(parsed) ? parsed : (Array.isArray(parsed?.rows) ? parsed.rows : null);
  if(!arr) throw new Error("Import failed: JSON must be an array of rows, or an object with a rows[] property.");
  const out = [];
  for(const entry of arr){
    const row = mapJsonEntry(entry);
    if(row?.date) out.push(row);
  }
  if(!out.length) throw new Error("Import failed: no valid rows found in JSON.");
  importRowsMerge(out);
}

// Hook up buttons/inputs
(function wireImportExport(){
  const importCsvBtn = document.getElementById("importCsvBtn");
  const exportCsvBtn = document.getElementById("exportCsvBtn");
  const exportJsonBtn = document.getElementById("exportJsonBtn");
  const csvInput = document.getElementById("importCsvInput");
  const jsonInput = document.getElementById("importFileInput");

  if(importCsvBtn && csvInput){
    importCsvBtn.addEventListener("click", ()=> csvInput.click());
    csvInput.addEventListener("change", async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      try{
        setImportStatus("Importing CSV…");
        const txt = await readFileAsText(f);
        importFromCSVText(txt);
      }catch(err){
        setImportStatus(String(err?.message || err), true);
      }finally{
        e.target.value = "";
      }
    });
  }

  if(jsonInput){
    // The JSON button is "Restore JSON" in the UI
    const importJsonBtn = document.getElementById("importJsonBtn");
    if(importJsonBtn) importJsonBtn.addEventListener("click", ()=> jsonInput.click());
    jsonInput.addEventListener("change", async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      try{
        setImportStatus("Importing JSON…");
        const txt = await readFileAsText(f);
        importFromJSONText(txt);
      }catch(err){
        setImportStatus(String(err?.message || err), true);
      }finally{
        e.target.value = "";
      }
    });
  }

  if(exportCsvBtn){
    exportCsvBtn.addEventListener("click", async ()=>{
      try{
        await exportCSV();
        setImportStatus("Exported CSV.", false);
      }catch(err){
        setImportStatus(String(err?.message || err), true);
      }
    });
  }

  if(exportJsonBtn){
    exportJsonBtn.addEventListener("click", async ()=>{
      try{
        await exportJSON();
        setImportStatus("Exported JSON.", false);
      }catch(err){
        setImportStatus(String(err?.message || err), true);
      }
    });
  }
})();


  // Branch + changelog UI wiring
  document.addEventListener("DOMContentLoaded", () => {
    syncHeaderUI();
    const b1=document.getElementById("btnChangelog");
    const b2=document.getElementById("btnCloseChangelog");
    const ov=document.getElementById("changelogOverlay");
    if (b1) b1.addEventListener("click", openChangelog);
    if (b2) b2.addEventListener("click", closeChangelog);
    if (ov) ov.addEventListener("click", (e)=>{ if(e.target===ov) closeChangelog(); });

    const chk=document.getElementById("chkExperimental");
    if (chk){
      chk.addEventListener("change", () => {
        setExperimental(chk.checked);
        syncHeaderUI();
        try { render(); } catch(e){}
      });
    }
  });

</script>
</body>
</html>
<!-- Recommendation Distinctions -->
<div class="rec-legend">
  <h4>Movement Guidance (ADT / CFS)</h4>
  <ul>
    <li><strong>Maintain Rhythm — Go Wolf:</strong> Full walk. Natural pace. Hills allowed. Movement is the regulator.</li>
    <li><strong>Modulate & Observe — Stay in Motion:</strong> Full walk, gentler. End better than you started.</li>
    <li><strong>Morning Protection — Prime, Don’t Train:</strong> Short (10–30 min). Flat, slow, exploratory only.</li>
    <li><strong>Restore First — Movement Only If Regulating:</strong> Very short or none. Stability before motion.</li>
  </ul>
</div>
